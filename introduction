

<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>Introduction - Learn You a Haskell for Great Good!</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<base href="http://learnyouahaskell.com/">
<style type="text/css">
	@import url('reset.css');
	@import url('style.css');
</style>
<link rel="shortcut icon" href="favicon.png" type="image/png">
        <link rel="next" href="starting-out">
<link type="text/css" rel="stylesheet" href="sh/Styles/SyntaxHighlighter.css">
<link href="rss.php" rel="alternate" type="application/rss+xml" title="Learn You a Haskell for Great Good! feed">
</head>
<body class="introcontent">
<div class="bgwrapper">
    <div id="content">
                <div class="footdiv" style="margin-bottom:25px;">
                <ul>
                    <li style="text-align:left">
                                            </li>
                    <li style="text-align:center">
                        <a href="chapters">Table of contents</a>
                    </li>
                    <li style="text-align:right">
                                                        <a href="starting-out" class="nxtlink">Starting Out</a>
                                            </li>
                </ul>
            </div>
        <h1>Giriş</h1> 
<a name="about-this-tutorial"></a>
<h2>Tutorial Hakkında</h2>
<p>
<em>Kendinize Haskell Öğretin</em>'e hoşgeldiniz! 
Eğer bunu okuyorsanız Haskell öğrenmek istiyor olma ihtimaliniz yüksek. Tam yerine geldiniz, fakat ilk önce tutorial hakkında biraz konuşalım.
</p>
<p>
Bunu yazmaya karar verdim çünkü Haskell hakkındaki bilgilerimi pekiştirmek istedim ve düşündüm ki bu bilgilerle Haskell'a yeni başlayan sizlere kendi persfektifimden yardım edebilirim.İnternette dolaşan Haskell ile ilgili bir kaç tutorial mevcut. Ben Haskell'a başlarken tek bir kaynaktan öğrenmedim. Haskell'ı birden fazla kaynak ve makale okuyarak öğrendim çünkü makalelerin herbiri bilgileri diğerinden farklı bir yolla açıklıyordu.Bu sayede tüm parçalar tek bir yerde birleşti.Yani burda yapmaya çalıştığım şey Haskell öğrenmeniz için yeni bir kaynak oluşturmak bu sayede hangi kaynağı daha çok sevdiğinizi belirleme şansınız epeyce yükselecek.
</p>
<img src="http://s3.amazonaws.com/lyah/bird.png" alt="bird" class="left" width="230" height="192">
<p>
Bu tutorialde zorunlu dillerde tecrübesi olan (C, C++, Java, Python &hellip;) fakat fonksiyonel programlamada (Haskell, ML, OCaml &hellip;) tecrübesi olmayan kişiler hedef alınmıştır. Ancak bahse girerim programlama tecrübeniz olmasa bile sizin gibi zeki bir insan Haskell'ı rahatça öğrenebilir.
</p>
<p>
Freenode ağındaki #haskell birşeyler sormak istediğinizde size yardım edebilecek harika bir yerdir.Ordaki insanlar Haskell'a yeni başlayanların halinden çok iyi anlar ve onlara yardım edebilecek kadar güvenilir ve sabırlıdır.
</p>
<p>
Haskell'ı tamamen kavramadan önce yaklaşık olarak 2 kez başarısız oldum çünkü Haskell bana çok tuhaf gelmişti. Fakat zor olan ilk kısmı geçtiğimde rahatça deryaya yelken açtım. Anlatmaya çalıştığım şey şu: Haskell en başta tuhaf gelse de gerçekten öğrenilmesi gereken çok yararlı bir dildir. Haskell'ı öğrenmek yeni bir programlama diline başlamak gibidir &mdash; yani eğlencelidir! sizi farklı düşünmeye zorlar, neyse şimdi diğer bölüme geçelim &hellip;
</p>

<a name="so-whats-haskell"></a><h2>Haskell Nedir?</h2>
<p>
<img src="http://s3.amazonaws.com/lyah/fx.png" alt="fx" class="right" width="150" height="146">
Haskell <em>tamamen fonksiyonel bir programlama dili</em> dir.
Zorunlu dillerde bilgisayara bir dizi girdi verirsiniz bu bilgisayar onları çalıştırır. Bunları çalıştırırken durum değiştirebilir. Mesela <span class="fixed">a</span> diye bir değişken yarattınız ve onu 5'e eşitlediniz, birkaç iş yaptıktan sonra a'yı tekrar değiştirdiniz. Yapıların kontrol akışını bir işlemi birkaç kez yapmak için elinizde tutuyorsunuz.Tamamen fonksiyonel programlamada bilgisayara ne yapması gerektiğini değil yapılacak işin <i>ne</i> olduğunu söylüyorsunuz. Bir sayının faktöriyeli 1'den o sayıya kadar olan sayıların çarpımıdır, bir sayı listesinin toplamı o sayı ve listedeki diğer sayıların toplamıdır, gibi örnekler verilebilir. Yapmak istediğiniz şeyi fonksiyonlarla anlatıyorsunuz. Aynı zamanda bir değişkeni bir değere atayıp sonra onu başka bir değere atayamazsınız. Eğer <span class="fixed">a</span> 'nın 5 olduğunu söylüyorsanız, sonrasında a'nın başka birşey olduğunu söyleyemezsiniz. Nesiniz siz, bir çeşit yalancı mı? Yani tamamen fonksiyonel programlamada fonksiyonun yan etkisi yoktur. Fonksiyonun yapabileceği tek şey birşeyleri hesaplayıp geriye değer döndürmektir. İlk bakışta bu biraz sınırlayıcı gözükebilir,fakat aslında bu bazı güzel sonuçlar doğurur: Eğer bir fonksiyon aynı parametreler ile iki kez çağırılırsa aynı sonucu döndüreceği kesindir. Buna referential transparency denir ve bu hem derleyicinin programın davranışını sorgulamasına izin verir hem de sizin bir fonksiyonu kolayca anlayıp doğrulamanızı (hatta ispatlamanızı) ve sonrasında basit fonksiyonları birbirine yapıştırarak daha karmaşık fonksiyonları yaratmanızı sağlar.
</p>
<p>
<img src="http://s3.amazonaws.com/lyah/lazy.png" class="right" alt="lazy" width="240" height="209">
Haskell <em>tembel</em> dir. Bu, ek bilgi verilmedikçe veya sonuç göstermeye zorlanmadıkça programın herhangi bir ek fonksiyon çalıştırmayacağı veya birşeyler geri döndürmeyeceği anlamına gelir. Bu programları bir dizi <em>veri dönüşümü</em> olarak algılamanıza izin verir. Bu aynı zamanda sonsuz veriye sahip yapılar oluşturmak gibi havalı şeylere de izin verir. Sabit bir sayı listeniz <span class="fixed">xs = [1,2,3,4,5,6,7,8]</span> ve listedeki her elemanı 2 ile çarpıp yeni listeyi oluşturan bir fonksiyonunuz <span class="fixed">doubleMe</span> var diyelim. Eğer listemizi 8 ile çarpmak isteseydik zorunlu dillerde şunu yapmak zorunda kalacaktık <span class="fixed">doubleMe(doubleMe(doubleMe(xs)))</span>, bu yüzden program büyük ihtimalle listenin içinden geçerek bir kopya oluşturur ve sonrasında onu geri döndürürdü. Sonra ise bu işlemi 2 kez daha yapar ve asıl sonucu döndürürdü. Tembel bir dilde <span class="fixed">doubleMe</span> fonksiyonunu herhangi bir sonuç göstermesini istemeden çağırmak programın size "Tamam bea yaparım bi' ara" demesiyle sonuçlanır. Fakat sonucu görmek istediğiniz anda <span class="fixed">doubleMe</span> ikinciye sonucu hemen şimdi istediğini söyler. İkinci de üçüncüye aynı emri verir ve üçüncü isteksizce 1 çarpı 2 yani sonuç olarak 2'yi döndürür. İkinci 2'yi alarak aynı işlemi yapar ve birinciye gönderir ve birinci asıl sonucu geri döndürür. Yani fonksiyon sadece ihtiyacınız olduğu zaman listenin içinden geçer. That way when you want something from a lazy language you can just take some initial data and efficiently transform and mend it so it resembles what you want at the end.
</p>
<p>
<img src="http://s3.amazonaws.com/lyah/boat.png" class="right" alt="boat" width="160" height="153">
Haskell is <em>statically typed</em>. When you compile your program, the compiler knows which piece of code is a number, which is a string and so on. That means that a lot of possible errors are caught at compile time. If you try to add together a number and a string, the compiler will whine at you. Haskell uses a very good type system that has <em>type inference</em>. That means that you don't have to explicitly label every piece of code with a type because the type system can intelligently figure out a lot about it. If you say <span class="fixed">a = 5 + 4</span>, you don't have to tell Haskell that <span class="fixed">a</span> is a number, it can figure that out by itself. Type inference also allows your code to be more general. If a function you make takes two parameters and adds them together and you don't explicitly state their type, the function will work on any two parameters that act like numbers.
</p>
<p>
Haskell is <em>elegant and concise</em>. Because it uses a lot of high level concepts, Haskell programs are usually shorter than their imperative equivalents. And shorter programs are easier to maintain than longer ones and have less bugs.
</p>
<p>
    Haskell was made by some <em>really smart guys</em> (with PhDs). Work on Haskell began in 1987 when a committee of researchers got together to design a kick-ass language. In 2003 the Haskell Report was published, which defines a stable version of the language.
</p>
<a name="what-you-need"></a><h2>What you need to dive in</h2>
<p>
A text editor and a Haskell compiler. You probably already have your favorite text editor installed so we won't waste time on that. For the purposes of this tutorial we'll be using GHC, the most widely used Haskell compiler. The best way to get started is to download the <a href="http://hackage.haskell.org/platform/">Haskell Platform</a>, which is basically Haskell with batteries included.
</p>
<p>
GHC can take a Haskell script (they usually have a .hs extension) and compile it but it also has an interactive mode which allows you to interactively interact with scripts. Interactively. You can call functions from scripts that you load and the results are displayed immediately. For learning it's a lot easier and faster than compiling every time you make a change and then running the program from the prompt. The interactive mode is invoked by typing in <span class="fixed">ghci</span> at your prompt. If you have defined some functions in a file called, say, <span class="fixed">myfunctions.hs</span>, you load up those functions by typing in <span class="fixed">:l myfunctions</span> and then you can play with them, provided <span class="fixed">myfunctions.hs</span> is in the same folder from which <span class="fixed">ghci</span> was invoked. If you change the .hs script, just run <span class="fixed">:l myfunctions</span> again or do <span class="fixed">:r</span>, which is equivalent because it reloads the current script. The usual workflow for me when playing around in stuff is defining some functions in a .hs file, loading it up and messing around with them and then changing the .hs file, loading it up again and so on. This is also what we'll be doing here.
</p>
                <div class="footdiv">
                <ul>
                    <li style="text-align:left">
                                            </li>
                    <li style="text-align:center">
                        <a href="chapters">Table of contents</a>
                    </li>
                    <li style="text-align:right">
                                                        <a href="starting-out" class="nxtlink">Starting Out</a>
                                            </li>
                </ul>
            </div>
        </div>
    <script type="text/javascript" src="sh/Scripts/shCore.js"></script>
    <script type="text/javascript" src="shBrushHaskell.js"></script>
    <script type="text/javascript" src="shBrushPlain.js"></script>
    <script type="text/javascript">
    dp.SyntaxHighlighter.ClipboardSwf = '/sh/Scripts/clipboard.swf';
    dp.SyntaxHighlighter.HighlightAll('code', false, false, false, 1, false);
    </script>
</div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-4461592-3");
pageTracker._trackPageview();
</script>
</body>
</html>
