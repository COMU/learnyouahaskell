<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>Starting Out - Learn You a Haskell for Great Good!</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<base href="http://learnyouahaskell.com/">
<style type="text/css">
	@import url('reset.css');
	@import url('style.css');
</style>
<link rel="shortcut icon" href="favicon.png" type="image/png">
        <link rel="prev" href="introduction">
        <link rel="next" href="types-and-typeclasses">
<link type="text/css" rel="stylesheet" href="sh/Styles/SyntaxHighlighter.css">
<link href="rss.php" rel="alternate" type="application/rss+xml" title="Learn You a Haskell for Great Good! feed">
</head>
<body class="introcontent">
<div class="bgwrapper">
    <div id="content">
                <div class="footdiv" style="margin-bottom:25px;">
                <ul>
                    <li style="text-align:left">
                                                        <a href="introduction" class="prevlink">Tanıtım</a>
                                            </li>
                    <li style="text-align:center">
                        <a href="chapters">İçindekiler</a>
                    </li>
                    <li style="text-align:right">
                                                        <a href="types-and-typeclasses" class="nxtlink">Tipler ve Tip Sınıfları</a>
                                            </li>
                </ul>
            </div>
        <h1 style="margin-left:-3px">İlk Adım</h1>
<a name="ready-set-go"></a><h2>Hazır, başla!</h2>
<p>
<img src="http://s3.amazonaws.com/lyah/startingout.png" class="right" alt="egg" width="214" height="187">
Tamam, haydi başlayalım! Eğer tanıtımı okumadan geçen sabırsız kişilerdensen, tanıtımın son kısmını okumak isteyebilirsin çünkü bu eğitimi takip etmek için neye ihtiyacın olduğunu ve nasıl fonksiyon yükleyeceğimizi açıklıyor. Haskell hakkında temel bir fikir edinmeniz için yapacağımız ilk şey ghc'yi interaktif modda çalıştırmak ve bazı fonksiyonlar çağırmak olacak. Terminalinizi açın ve <span class="fixed">ghci</span> yazın. Böyle bir şeyle karşılacaksınız.
</p>
<pre name="code" class="haskell: ghci">
GHCi, version 6.8.2: http://www.haskell.org/ghc/  :? for help
Loading package base ... linking ... done.
Prelude&gt;</pre>
<p>
Tebrikler, GHCI'desiniz! ***The prompt here is <span class="fixed">Prelude&gt;</span> but because it can get longer when you load stuff into the session, we're going to use <span class="fixed">ghci&gt;</span>. Sizde de aynı prompt olsun istiyorsanız, sadece <span class="fixed">:set prompt "ghci&gt; "</span> yazın. 
</p>
<p>
İşte bazı basit aritmetikler.
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; 2 + 15
17
ghci&gt; 49 * 100
4900
ghci&gt; 1892 - 1472
420
ghci&gt; 5 / 2
2.5
ghci&gt;</pre>
<p>
Burası oldukça anlaşılır. Bir satırda birkaç işleç de kullanabiliriz. İşlem önceliği alışıldığı gibidir. Önceliği değiştirmek ve ya açıklık getirmek için parantezlerden yararlanabiliriz.
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; (50 * 100) - 4999
1
ghci&gt; 50 * 100 - 4999
1
ghci&gt; 50 * (100 - 4999)
-244950</pre>
<p>
Oldukça harika, değil mi? Tamam, biliyorum değil ama sabredin. Sayıları negatif hale getirirken biraz dikkat etmek gerekiyor. Eğer bir negatif sayı istiyorsak, her zaman en iyisi onu parantezlerle çevrelemek. Böyle yazarsan <span class="fixed">5 * -3</span> GHCI seni uyaracaktır ama böyle yazarsan <span class="fixed">5 * (-3)</span> sorunsuz çalışacaktır.
</p>
<p>
Boolean cebri de oldukça basit. Muhtemelen bilirsin, <span class="fixed">&amp;&amp;</span> boolen <i>ve</i>, <span class="fixed">||</span> boolen <i>ve ya</i> anlamına geliyor. <span class="fixed">not</span>, <span class="fixed">True</span> ve ya <span class="fixed">False</span>'u negatif hale çevirir.
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; True &amp;&amp; False
False
ghci&gt; True &amp;&amp; True
True
ghci&gt; False || True
True 
ghci&gt; not False
True
ghci&gt; not (True &amp;&amp; True)
False</pre>
<p>
Eşitliği test etmek şöyle yapılabilir.
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; 5 == 5
True
ghci&gt; 1 == 0
False
ghci&gt; 5 /= 5
False
ghci&gt; 5 /= 4
True
ghci&gt; "hello" == "hello"
True </pre>
<p>
Acaba <span class="fixed">5 + "llama"</span> ya da <span class="fixed">5 == True</span> yaparsak ne olur? Eğer ilk kodu denersek, büyük korkunç bir hata mesajı alırız!
</p>
<pre name="code" class="haskell: ghci">
No instance for (Num [Char])
arising from a use of `+' at &lt;interactive&gt;:1:0-9
Possible fix: add an instance declaration for (Num [Char])
In the expression: 5 + "llama"
In the definition of `it': it = 5 + "llama" </pre>
<p>
Eyvah! Burada GHCI bize <span class="fixed">"llama"</span>'nın bir sayı olmadığını ve 5'e nasıl ekleyeceğini bilmediğini söylüyor. Eğer <span class="fixed">"llama"</span> değil <span class="fixed">"four"</span> ya da <span class="fixed">"4"</span> olsaydı, Haskell hala onun sayı olduğunu anlayamazdı. <span class="fixed">+</span> sağ ve sol tarafının sayı olmasını bekler. Eğer <span class="fixed">True == 5</span> denersek, GHCI bize tiplerin uyuşmadığını söyler. Oysa <span class="fixed">+</span> sadece sayı kabul edilen şeyler üzerinde çalışırken, <span class="fixed">==</span> karşılaştırılabilen herhangi iki şey üzerinde çalışır. Ama önemli nokta her ikisinin de aynı tip materyalleri işleyebilmesi. Elma ile portakalı karşılaştıramazsın. İleride tiplere daha yakından bakacağız. Not: <span class="fixed">5 + 4.0</span> yazabilirsin çünkü <span class="fixed">5</span> sinsidir ve hem tam sayı hem de küsürlü sayı gibi davranabilir. <span class="fixed">4.0</span> tam sayı gibi davranamaz, bu yüzden <span class="fixed">5</span> de buna ayak uydurmak zorudadır.
</p>
<p>
Fark etmemiş olabilirsin ama başından beri hep fonksiyonları kullandık. Örneğin, <span class="fixed">*</span> iki sayı alan ve onları çarpan bir fonksiyon. Az önce gördüğün gibi, onu iki sayı arasında çağırmıştık. Biz böyle fonksiyonlara <i>infix</i> fonksiyon diyoruz. Sayılarla beraber kullanılmayan birçok fonksiyon <i>prefix</i> fonksiyondur. Haydi onlara bakalım. 
</p>
<p>
<img src="http://s3.amazonaws.com/lyah/ringring.png" alt="phoen" class="right" width="160" height="161">
Şimdiye kadar belitmemiştik ama kullandığımız fonksiyonlar çoğunlukla prefix yapıdaydı, biraz önce bundan bahsettik. Çoğu imperatif dilde fonksiyonlar, fonksiyon adı ile çağırılır ardından parantez içerisinde paramatreleri vardır, parametlerler de genellikle virgüllerle ayrılır. Haskell'de fonksiyonlar, fonksiyon adı sonra bir boşluk ardından parametlerleri yazılarak çağırılır. Parametreler de birbirlerinden birer boşlukla ayrılır. Başlangıç için, Haskell'deki en sıkıcı fonksiyonlardan birini çağırmayı deneyeceğiz.
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; succ 8
9 </pre>
<p>
<span class="fixed">succ</span> fonksiyonu ardılı olan herhangi bir şey alır ve onun ardılını döndürür. Gördüğün gibi, fonksiyon adını parametresinden bir boşlukla ayırdık. Bir fonksiyonu birkaç parametreyle çağırmak da kolay. <span class="fixed">min</span> ve <span class="fixed">max</span> fonksiyonları sıralanabilecek herhangi iki şey alır (sayı gibi!). <span class="fixed">min</span> küçük olanı döndürürken and <span class="fixed">max</span> büyük olanı döndürür. Kendin bak:
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; min 9 10
9
ghci&gt; min 3.4 3.2
3.2
ghci&gt; max 100 101
101 </pre>

<p>
Fonksiyon kullanımı (fonksiyon çağırma ardından birer boşlukla parametreleri yazmak) en yüksek önceliklidir. Bu aşağıdaki iki ifadenin eşit olduğu anlamına geliyor.
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; succ 9 + max 5 4 + 1
16
ghci&gt; (succ 9) + (max 5 4) + 1
16
</pre>
<p>
Eğer 9 ve 10'un sonucunun bir fazlasını istiyorsak, <span class="fixed">succ 9 * 10</span> yazmamalıyız çünkü bu 9'un bir fazlası ile 10'un çarpımıdır. Yani 100. 91 sonucunu almak için <span class="fixed">succ (9 * 10)</span> yazmalıyız.
</p>
<p>Eğer fonksiyon iki parametre alıyorsa, fonksiyonu backticklerin arasına alarak infix yapıda da çağırabiliriz. Örneğin, <span class="fixed">div</span> fonksiyonu iki tamsayı alır ve tam bölme yapar. <span class="fixed">div 92 10</span> işleminin sonucu 9'dur. Ama bu şekilde çağırmamız bölen ile bölüneni karıştırmamıza neden olabilir. İnfix fonksiyon olarak çağırdığımızda ise, <span class="fixed">92 `div` 10</span> aniden daha anlaşılır oldu. </p>
<p>İmperatif dillerle geçmişi olan çoğu insan parantezin fonksiyon bildirmesi gerektiği düşüncesinden sapamıyor. Örneğin, C'de <span class="fixed">foo()</span>, <span class="fixed">bar(1)</span> ya da <span class="fixed">baz(3, "haha")</span> gibi fonksiyonları parantezlerle çağırırsın. Söylediğimiz gibi, Haskell'de fonksiyon kullanımında boşluklar kullanılır. Bu fonksiyonlar Haskell'de <span class="fixed">foo</span>, <span class="fixed">bar 1</span> ve <span class="fixed">baz 3 "haha"</span> şeklinde olmalıdır. <span class="fixed">bar (bar 3)</span> gibi bir şey görürsen; <span class="fixed">bar</span>, <span class="fixed">bar</span> ve <span class="fixed">3</span> parametreleriyle çağırılmış anlamına gelmez. Bu <span class="fixed">bar</span> fonksiyonunu <span class="fixed">3</span> parametresi ile çağırıp, bundan elde edilen sonuc ile yine <span class="fixed">bar</span> fonksiyonunu çağırdığımız anlamına gelir. C'de, bu şekilde olmalı <span class="fixed">bar(bar(3))</span>.</p>
<a name="babys-first-functions"></a><h2>Baby's first functions</h2>
<p>
Önceki bölümde fonksiyon kullanımları ile ilgili temel fikir edindik. Haydi şimdi iyice anlayalım! En sevdiğin metin editörünü aç ve bir sayı alıp onu ikiyle çarpan bir fonksiyon yaz.
</p>
<pre name="code" class="haskell: hs">
doubleMe x = x + x</pre>
<p>
Fonksiyonlar, çağırımlarına benzer şekilde tanımlanır. Önce fonksiyon adı yazılır ardından parametreleri de aralarında boşluk olacak şekilde yerleştirilir. ***Ama fonksiyon tanımlarken, <span class="fixed">=</span> kullanılır ardından da fonksiyonun ne yaptığı tanımlanır. Bunu <span class="fixed">baby.hs</span> olarak kaydedin. Kaydettiğiniz dizine gidin ve <span class="fixed">ghci</span>'yi orada çalıştırın. GHCI içinde bir kez <span class="fixed">:l baby</span> yapın. Şimdi scriptimiz yüklendi, artık tanımladığımız fonksiyonlarla oynayabiliriz.
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; :l baby
[1 of 1] Compiling Main             ( baby.hs, interpreted )
Ok, modules loaded: Main.
ghci&gt; doubleMe 9
18
ghci&gt; doubleMe 8.3
16.6 </pre>
<p>
Çünkü <span class="fixed">+</span> tamsayılarla çalıştığı gibi gerçel sayılarla da çalışır (Herhangi birşey sayı olarak kabul edilebilir, gerçekten),fonksiyonumuz herhangi bir sayıyla da çalışır. Haydi bir fonksiyon yazalım. Bu fonksiyon iki sayı alsın, onları iki ile çarpıp birbiri ile toplasın.
</p>
<pre name="code" class="haskell: hs">
doubleUs x y = x*2 + y*2 </pre>
<p>
Basit. Şu şekilde de tanımlayabilirdik <span class="fixed">doubleUs x y = x + x + y + y</span>. Test edin, oldukça tahmin edilebilir sonuçlar veriyor (Unutma, bu fonksiyonu <span class="fixed">baby.hs</span> dosyasına ekleyip kaydettikten sonra GHCI içinde tekrar <span class="fixed">:l baby</span> yapmalısın).
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; doubleUs 4 9
26
ghci&gt; doubleUs 2.3 34.2
73.0
ghci&gt; doubleUs 28 88 + doubleMe 123
478
</pre>
<p>
Tahmin edeceğin gibi, kendi ürettiğin fonksiyonları yine kendi ürettiğin fonksiyonlarla çağırabilirsin. Yani, <span class="fixed">doubleUs</span> fonksiyonunu bu şekilde yeniden tanımlayabiliriz:
</p>
<pre name="code" class="haskell: hs">
doubleUs x y = doubleMe x + doubleMe y </pre>
<p>
Bu da Haskell boyunca karşılaşacağın genel şablona çok basit bir örnek. Basit fonksiyonlar yazmak ve onları birleştirerek daha karmaşık fonksiyonlar elde etmek oldukça doğru olur. Aynı zamanda basit fonksiyon içeriğini tekrarlama gereği kalmaz. Ya bazı matematikçiler 2'nin aslında 3 olduğunu bulur, senin de programını değiştirmen gerekirse? Sadece <span class="fixed">doubleMe</span>'yi <span class="fixed">x + x + x</span> olarak yeniden tanımlarsın. Artık <span class="fixed">doubleUs</span> yeni <span class="fixed">doubleMe</span> fonksiyonunu çağıracak ve 2'nin 3 olduğu bu garip dünyada otomatik olarak çalışacaktır.
</p>
<p>Haskell'de fonksiyonlar tanımlanırken belirli bir sıraları yoktur, yani <span class="fixed">doubleMe</span>'yi önce tanımlayıp sonra <span class="fixed">doubleUs</span>'ı tanımlaman bir şey değiştirmez. Bu diğer türlü yaparsan da geçerli.</p>
<p>Şimdi bir sayı alan ve onu 2 ile çarpan bir fonksiyon yazıcaz ama bu fonksiyon eğer sayı 100'den küçük ya da eşitse onu 2 ile çarpıcak. ***Çünkü 100'den büyük sayılar yeterince büyükler.
</p>
<pre name="code" class="haskell: hs">
doubleSmallNumber x = if x &gt; 100
                        then x
                        else x*2 </pre>
<img src="http://s3.amazonaws.com/lyah/baby.png" alt="this is you" class="left" width="140" height="211">
<p>
Burada Haskell'deki if ile tanıştık. Muhtemelen if'e diğer dillerden alışkınsındır. Haskell'deki if ile imperatif dillerdeki if arasındaki fark ise else kısmının zorunlu olmasıdır. İmperatif dillerde eğer koşul sağlanmazsa sadece birkaç adımı atlarsın ama Haskell'de her ifade ve fonksiyon bir şey döndürmek zorundadır. Ayrıca if'i tek satırda da yazabiliriz. Haskell'deki if hakkında bir başka şey ise bir şey <i>ifade</i> etmesi yani değer döndürmesidir. <span class="fixed">5</span> 5 değerini döndüren bir ifadedir, <span class="fixed">4 + 8</span> bir ifadedir, <span class="fixed">x + y</span> de bir ifadedir çünkü <span class="fixed">x</span> ve <span class="fixed">y</span>'nin toplamının değerini döndürür. İf her zaman bir değer döndürür çünkü else kullanımı zorunludur. Bundan dolayı if her zaman bir ifadedir. Eğer fonksiyonumuz tarafından üretilmiş her değere bir eklemek istiyorsak, fonksiyonun gövdesini şu şekilde yazmalıyız.
</p>
<pre name="code" class="haskell: hs">
doubleSmallNumber' x = (if x &gt; 100 then x else x*2) + 1
</pre>
<p>
Eğer parantezleri ihmal etmiş olsaydık, sadece <span class="fixed">x</span> 100'den büyük olmadığı zaman 1 ekleyecekti. Fonksiyon adı sonundaki <span class="fixed">'</span> işaretine dikkat et. Kesme işareti Haskell'in sözdiziminde herhangi özel bir anlamı yoktur. Yani fonksiyon adlarında kullanılabilir. Genellikle, <span class="fixed">'</span> işaretini ya bir fonksiyonun son halini belirtmek için (burada tembel değil) ya da bir fonksiyon veya bir değişkenin ufak değişiklikler sonucunda son halini göstermek için kullanırız. Yani bu şekilde bir fonksiyon oluşturabiliriz.
</p>
<pre name="code" class="haskell: hs">
conanO'Brien = "It's a-me, Conan O'Brien!" </pre>
<p>
Burada kaydadeğer iki şey var. İlki fonksiyon başında yani Conan'ın adını yazarken büyük harfle başlamadık. Çünkü fonksiyon adları büyük harfle başlamaz. Neden olduğunu daha sonra göreceğiz. İkincisi bu fonksiyon hiç parametre almadı. Bir fonksiyon hiç parametre almadıysa, her zaman <i>tanımlama</i> olduğunu söyleriz (ya da <i>atama</i>). Çünkü bir kez tanımladıktan sonra ***isimlerin (ve fonksiyonların) anlamlarını değiştiremeyiz. <span class="fixed">conanO'Brien</span> ve <span class="fixed">"It's a-me, Conan O'Brien!"</span> dizgesi birbirinin yerine kullanılabilir.
</p>
<a name="an-intro-to-lists"></a><h2>Listelere giriş</h2>
<p>
<img src="http://s3.amazonaws.com/lyah/list.png" alt="BUY A DOG" class="left" width="150" height="103">
Haskell'deki listeler de gerçek hayattaki alışveriş listeleri gibi çok kullanışlıdır. En çok kullanılan veri yapısıdır. Birçok farklı yolla bir sürü problemi modelleyip çözmede kullanılabilir. Listeler ÇOK harikadır. Bu bölümde temel anlamda listelere, dizgelere (onlarda birer liste) ve liste kavramlarına göz atacağız.
</p>
<p>
Haskell'de listeler <em>türdeş</em> veri yapılarıdır. Aynı tipte olan birkaç öğe saklarlar. Yani bir birkaç tamsayı ve ya birkaç karakter saklayan listeler oluşturabiliriz ama aynı anda hem tamsayı hem de karakter içeren bir liste oluşturamayız. Ve sonunda bir liste!
</p>
<div class="hintbox"><em>Not</em>: GHCI'de <span class="fixed">let</span> anahtar kelimesini kullanarak bir ismi tanımlayabiliriz. GHCI'de <span class="fixed">let a = 1</span> yapmak ile bir komuta <span class="fixed">a = 1</span> yazıp, çalıştırmak aynı şeylerdir.</div>
<pre name="code" class="haskell: ghci">
ghci&gt; let lostNumbers = [4,8,15,16,23,42]
ghci&gt; lostNumbers
[4,8,15,16,23,42]
</pre>
<p>
Gördüğün gibi, listeler köşeli parantez ile belirtildi ve değerler virgüllerle birbirinden ayrıldı. Eğer <span class="fixed">[1,2,'a',3,'b','c',4]</span> şeklinde birşey denersek,  Haskell karakterlerin (Bu arada, kesme işareti arasına alınanlar karakter) sayı olamadığına yakınacaktır. Karakterlerden bahsetmişken, dizgeler de sadece karakterlerden oluşan listelerdir. <span class="fixed">"hello"</span> sadece <span class="fixed">['h','e','l','l','o']</span> dizisinin sadece sözdizimsel şekeridir. Dizgeler de birer liste olduğundan liste fonksiyonları onlar üzerinde de kullanabiliriz. Buda oldukça kullanışlı. 
</p>
<p>En çok yapılan iki listeyi birleştirme işlemi. Bunu <span class="fixed">++</span> işlecini ile yaparız. </p>
<pre name="code" class="haskell: ghci">
ghci&gt; [1,2,3,4] ++ [9,10,11,12]
[1,2,3,4,9,10,11,12]
ghci&gt; "hello" ++ " " ++ "world"
"hello world"
ghci&gt; ['w','o'] ++ ['o','t']
"woot"
</pre>
<p>
Uzun dizgelerde <span class="fixed">++</span> işlecini art arda kullanırken dikkatli ol. İki listeyi bir araya getirirken (hatta tek eleman tutan bir listeyi diğer listeye eklesen bile, öreneğin: <span class="fixed">[1,2,3] ++ [4]</span>), Haskell'in <span class="fixed">++</span> işlecinin sol tarafındaki listenin tümünü okuması gerekir. Bu çok büyük olmayan listelerle uğraşırken sorun değil. Ama elli milyon girdisi bulunan büyük bir listeye eklemek epey zaman alır. Oysa, bir listenin başına <span class="fixed">:</span> işlecini kullanarak şipşak birşey eklenebilir.
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; 'A':" SMALL CAT"
"A SMALL CAT"
ghci&gt; 5:[1,2,3,4,5]
[5,1,2,3,4,5]
</pre>
<p>
Uyarı. <span class="fixed">:</span> işleci bir sayı ve sayılardan oluşan liste ve ya bir karakter ve karakterlerden oluşan liste alır ,ama <span class="fixed">++</span> işleci iki liste alır. <span class="fixed">++</span> işleciyle listenin sonuna öğe eklesen bile, öğeyi köşeli parantezlerin arasına almalısın ki liste haline gelsin.</p>
<p>
<span class="fixed">[1,2,3]</span> de aslında sadece <span class="fixed">1:2:3:[]</span> ifadesinin sözdizimsel şekeridir. <span class="fixed">[]</span> bir boş listedir. Eğer başına <span class="fixed">3</span> eklersek, <span class="fixed">[3]</span> halini alır. Başına <span class="fixed">2</span> eklersek, <span class="fixed">[2,3]</span> olur, ve böyle devam eder.
</p>
<p class="hintbox"><em>Note:</em> <span class="fixed">[]</span>, <span class="fixed">[[]]</span> and<span class="fixed">[[],[],[]]</span> are all different things. The first one is an empty list, the seconds one is a list that contains one empty list, the third one is a list that contains three empty lists.</p>
<p>If you want to get an element out of a list by index, use <span class="fixed">!!</span>. The indices start at 0.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; "Steve Buscemi" !! 6
'B'
ghci&gt; [9.4,33.2,96.2,11.2,23.25] !! 1
33.2
</pre>
<p>But if you try to get the sixth element from a list that only has four elements, you'll get an error so be careful!</p>
<p>
Lists can also contain lists. They can also contain lists that contain lists that contain lists &hellip;
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; let b = [[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
ghci&gt; b
[[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
ghci&gt; b ++ [[1,1,1,1]]
[[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3],[1,1,1,1]]
ghci&gt; [6,6,6]:b
[[6,6,6],[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
ghci&gt; b !! 2
[1,2,2,3,4] </pre>
<p>The lists within a list can be of different lengths but they can't be of different types. Just like you can't have a list that has some characters and some numbers, you can't have a list that has some lists of characters and some lists of numbers.</p>
<p>Lists can be compared if the stuff they contain can be compared. When using <span class="fixed">&lt;</span>, <span class="fixed">&lt;=</span>, <span class="fixed">&gt;</span> and <span class="fixed">&gt;=</span> to compare lists, they are compared in lexicographical order. First the heads are compared. If they are equal then the second elements are compared, etc.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; [3,2,1] &gt; [2,1,0]
True
ghci&gt; [3,2,1] &gt; [2,10,100]
True
ghci&gt; [3,4,2] &gt; [3,4]
True
ghci&gt; [3,4,2] &gt; [2,4]
True
ghci&gt; [3,4,2] == [3,4,2]
True
</pre>
<p>
What else can you do with lists? Here are some basic functions that operate on lists.
</p>
<p><span class="label function">head</span> takes a list and returns its head. The head of a list is basically its first element.
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; head [5,4,3,2,1]
5 </pre>
<p><span class="label function">tail</span> takes a list and returns its tail. In other words, it chops off a list's head.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; tail [5,4,3,2,1]
[4,3,2,1] </pre>
<p><span class="label function">last</span> takes a list and returns its last element.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; last [5,4,3,2,1]
1 </pre>
<p><span class="label function">init</span> takes a list and returns everything except its last element.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; init [5,4,3,2,1]
[5,4,3,2] </pre>
<p>If we think of a list as a monster, here's what's what.</p>
<img src="http://s3.amazonaws.com/lyah/listmonster.png" alt="list monster" class="center" width="580" height="290">
<p>But what happens if we try to get the head of an empty list?</p>
<pre name="code" class="haskell: ghci">
ghci&gt; head []
*** Exception: Prelude.head: empty list</pre>
<p>Oh my! It all blows up in our face! If there's no monster, it doesn't have a head. When using <span class="fixed">head</span>, <span class="fixed">tail</span>, <span class="fixed">last</span> and <span class="fixed">init</span>, be careful not to use them on empty lists. This error cannot be caught at compile time so it's always good practice to take precautions against accidentally telling Haskell to give you some elements from an empty list.
<p><span class="label function">length</span> takes a list and returns its length, obviously.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; length [5,4,3,2,1]
5</pre>
<p><span class="label function">null</span> checks if a list is empty. If it is, it returns <span class="fixed">True</span>, otherwise it returns <span class="fixed">False</span>. Use this function instead of <span class="fixed">xs == []</span> (if you have a list called <span class="fixed">xs</span>)</p>
<pre name="code" class="haskell: ghci">
ghci&gt; null [1,2,3]
False
ghci&gt; null []
True</pre>
<p><span class="label function">reverse</span> reverses a list.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; reverse [5,4,3,2,1]
[1,2,3,4,5]</pre>
<p><span class="label function">take</span> takes number and a list. It extracts that many elements from the beginning of the list. Watch.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; take 3 [5,4,3,2,1]
[5,4,3]
ghci&gt; take 1 [3,9,3]
[3]
ghci&gt; take 5 [1,2]
[1,2]
ghci&gt; take 0 [6,6,6]
[]</pre>
<p>See how if we try to take more elements than there are in the list, it just returns the list. If we try to take 0 elements, we get an empty list.</p>
<p><span class="label function">drop</span> works in a similar way, only it drops the number of elements from the beginning of a list.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; drop 3 [8,4,2,1,5,6]
[1,5,6]
ghci&gt; drop 0 [1,2,3,4]
[1,2,3,4]
ghci&gt; drop 100 [1,2,3,4]
[] </pre>
<p><span class="label function">maximum</span> takes a list of stuff that can be put in some kind of order and returns the biggest element.</p><p> <span class="label function">minimum</span> returns the smallest.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; minimum [8,4,2,1,5,6]
1
ghci&gt; maximum [1,9,2,3,4]
9 </pre>
<p><span class="label function">sum</span> takes a list of numbers and returns their sum.</p><p><span class="label function">product</span> takes a list of numbers and returns their product.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; sum [5,2,1,6,3,2,5,7]
31
ghci&gt; product [6,2,1,2]
24
ghci&gt; product [1,2,5,6,7,9,2,0]
0 </pre>
<p><span class="label function">elem</span> takes a thing and a list of things and tells us if that thing is an element of the list. It's usually called as an infix function because it's easier to read that way.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; 4 `elem` [3,4,5,6]
True
ghci&gt; 10 `elem` [3,4,5,6]
False
</pre>
<p>Those were a few basic functions that operate on lists. We'll take a look at more list functions <a href="modules#data-list">later</a></p>
<a name="texas-ranges"></a><h2>Texas menzilleri</h2>
<p>
<img src="http://s3.amazonaws.com/lyah/cowboy.png" alt="draw" class="right" width="200" height="258">
Peki,1 ile 20 arasındaki sayıları içeren bir liste yapmak isteseydik ne yapardık? Tabiki 1'den 20'ye kadar olan sayıları sırayla yazabiliriz,fakat kullandığı programlama dilinden mükemmel bir şekilde yararlanmak isteyen bir centilmen bunu yapmak istemez. Bunun yerine texas menzillerini kullanacağız. Menziller numaralandırılabilen aritmetik serileri içeren listeleri yapmanın yollarından biridir. Sayılar numaralandırılabilir. Bir,iki,üç vs. Karakterler de numaralandırılabilir. Alfabe A'dan Z'ye kadar olan karakterlerin numaralandırılmış halidir. İsimler numaralandırılamaz. "Ali" den sonra ne gelir? Bilmem.
</p>
<p>1'den 20'ye kadar olan tüm sayıları içeren bir liste yapmak için, sadece <span class="fixed">[1..20]</span> yazabilirsiniz. Bu <span class="fixed">[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]</span> yazmakla aynıdır ,bu ikisinin arasındaki tek fark birinin uzun olmasıdır ve bana sorarsanız uzun olanı seçmek dümdüz salaklıktır.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; [1..20]
[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
ghci&gt; ['a'..'z']
"abcdefghijklmnopqrstuvwxyz"
ghci&gt; ['K'..'Z']
"KLMNOPQRSTUVWXYZ" </pre>
<p>
Menziller havalıdır çünkü bir atlamayı belirtebilirsiniz. 1 ile 20 arasındaki çift sayıları isteseydik nasıl isterdik? veya 1 ile 20 arasındaki 3'ün katlarını?
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; [2,4..20]
[2,4,6,8,10,12,14,16,18,20]
ghci&gt; [3,6..20]
[3,6,9,12,15,18] </pre>
<p>Bunu sadece ilk iki elementi virgülle ayırarak ve üst limitin ne olduğunu belirterek yapabilirsiniz. Haskell zekidir fakat bazı insanların olmasını istediği kadar değil. <span class="fixed">[1,2,4,8,16..100]</span> yazıp ikinin kuvvetlerini almayı bekleyemezsiniz. Bir;çünkü sadece bir atlama belirtebilirsiniz. İki;Eğer terimlerinden sadece birkaçı verildiyse aritmetik olmayan seriler belirsizdir.
</p>
<p>20'den 1'e kadar olan sayıların listesini yapmak isterseniz, sadece <span class="fixed">[20..1]</span> yazamazsınız, <span class="fixed">[20,19..1]</span> yazmak zorundasınız.</p>
<p>Menzillerde ondalıklı sayıları kullanırken dikkat edin! Çünkü tam değillerdir. Menzillerdeki kullanımları ilginç sonuçlara yol açabilir.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; [0.1, 0.3 .. 1]
[0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999]
</pre>
<p>Benim tavsiyem onları menzillerde kullanmayın.</p>
<p>
Menzilleri üst limit belirlemeyerek sınırsız listeler yaratmak için kullanabilirsiniz. Bunu sonra konuşacağız. Şimdi, 13'ün ilk 24 katını nasıl alabileceğinizi inceleyelim. Tabiki <span class="fixed">[13,26..24*13]</span> yazabilirsiniz. Fakat daha iyi bir yol var: <span class="fixed">take 24 [13,26..]</span>. Çünkü Haskell tembeldir, hemen sınırsız listeleri hesaplamaya çalışmayacaktır çünkü hiç bitiremez. Sizin bu listeden ne istediğinizi anlayana kadar bekleyecektir. Burda ilk 24 elementi istediğinizi gördüğü için memmuniyetle baş eğecektir.
</p>
<p>Sınırsız listeler oluşturmak için kullanılan birkaç fonksiyon:</p>
<p><span class="label function">cycle</span> bir liste alır ve onu sonsuz listeye devirler. Sonucu çıktı almaya çalışırsanız sonsuza kadar gidecektir yani bir yerde sizin bunu kesmeniz gerekir.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; take 10 (cycle [1,2,3])
[1,2,3,1,2,3,1,2,3,1]
ghci&gt; take 12 (cycle "LOL ")
"LOL LOL LOL " </pre>
<p><span class="label function">repeat</span> bir element alır ve sadece o elementten sonsuz bir liste yaratır. Bu tek element ile listeyi devirlemeye benzer.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; take 10 (repeat 5)
[5,5,5,5,5,5,5,5,5,5]
</pre>
<p>Aynı elementten listede birkaç tane istiyorsanız <span class="label function">replicate</span> fonksiyonunu da kullanabilirsiniz. <span class="fixed">replicate 3 10</span> yazarsanız <span class="fixed">[10,10,10]</span> döndürür.</p>
<a name="im-a-list-comprehension"></a><h2>Ben bir liste üreteciyim</h2>
<p>
<img src="http://s3.amazonaws.com/lyah/kermit.png" alt="frog" class="left" width="180" height="156">
Eğer daha önce bir matematik dersi aldıysanız büyük ihtimalle <i>dizi üreteçleri</i> ne bakmışsınızdır. Normalde genel dizilerden özel diziler oluşturmak için kullanılırlar. İlk 10 çift tamsayıyı üreten temel bir üreteç <img src="http://s3.amazonaws.com/lyah/setnotation.png" alt="set notation"> halinde yazılabilir. Borudan önceki kısım çıktı fonksiyonudur. <span class="fixed">x</span> değişken, <span class="fixed">N</span> girdi kümesi, <span class="fixed">x &lt;= 10</span> ise koşuldur. Bu listede koşulun önerdiği gibi 1'den 10'a kadar sayıların yazıldığı ve sonrasında ise listedeki her sayının 2 ile çarpıldığı anlamına gelir.
</p>
<p>Eğer bunu Haskell'da yazmak isteseydik <span class="fixed">take 10 [2,4..]</span> gibi birşey yazabilirdik. Peki atlama yerine 1'den 10'a kadar olan sayıları bir fonksiyona sokmak isteseydik? Bunun için liste üreteçlerini kullanmamız gerekir. Şimdilik ilk 10 çift tamsayıyı yazmak olarak işe başlayacağız. Kullanacağımız liste üreteci <span class="fixed">[x*2 | x &lt;- [1..10]]</span> olacak. <span class="fixed">x</span> ise burda <span class="fixed">[1..10]</span> listesindeki her eleman olacak. Uygulaması alttaki gibidir.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; [x*2 | x <- [1..10]]
[2,4,6,8,10,12,14,16,18,20]
</pre>
<p>Gördüğünüz üzere istediğimiz sonuçlara ulaştık. Şimdi fonksiyona bir koşul ekleyelim. Koşullar bağlayıcı bölümlerden sonra gelir ve virgül ile ayrılır. 12'ye eşit veya 12'den büyük olan çift sayıları istiyoruz diyelim.
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; [x*2 | x <- [1..10], x*2 >= 12]
[12,14,16,18,20]
</pre>
<p>Güzel,çalışıyor. Peki 50'den 100'e kadar olan sayıların içinde 7'ye bölündüğünde 3 kalanını veren sayıları bulalım desek? O da kolay .</p>
<pre name="code" class="haskell: ghci">
ghci&gt; [ x | x &lt;- [50..100], x `mod` 7 == 3]
[52,59,66,73,80,87,94] </pre>
<p>İşte bu! Listeleri koşullarla ayıklamaya aynı zamanda <em>süzme</em> denir. Bir dizi numara aldık ve onları koşullar ile süzdük. Şimdi başka bir örnek daha yapalım, 10'dan büyük her tek sayıyı <span class="fixed">"BANG!"</span>, 10'dan küçük olan her tek sayıyı <span class="fixed">"BOOM!"</span> ile değiştiren bir üreteç yapalım. Eğer sayı tek değilse listeden çıkartıyoruz. Kolaylık olsun diye bunu bir fonksiyonun içine koyacağız, sonrasında rahatça kullanalım diye.</p>
<pre name="code" class="haskell: ghci">
boomBangs xs = [ if x &lt; 10 then "BOOM!" else "BANG!" | x &lt;- xs, odd x] </pre>
<p>Üreteçin son kısmı koşuldur. <span class="fixed">odd</span> fonksiyonu tek sayılarda <span class="fixed">True</span> döndürürken çift sayılarda <span class="fixed">False</span> döndürür. Element listeye sadece koşullar sağlanıyorsa koyulur.
<pre name="code" class="haskell: hs">
ghci&gt; boomBangs [7..13]
["BOOM!","BOOM!","BANG!","BANG!"] </pre>
<p>Birden fazla koşul yaratabiliriz. Eğer 10'dan 20'ye kadar 13,15,19 olmayan tüm sayıları isteseydik bunu yapardık:</p> <pre name="code" class="haskell: ghci">
ghci&gt; [ x | x &lt;- [10..20], x /= 13, x /= 15, x /= 19]
[10,11,12,14,16,17,18,20]</pre>
<p>Not only can we have multiple predicates in list comprehensions (an element must satisfy all the predicates to be included in the resulting list), we can also draw from several lists. When drawing from several lists, comprehensions produce all combinations of the given lists and then join them by the output function we supply. A list produced by a comprehension that draws from two lists of length 4 will have a length of 16, provided we don't filter them. If we have two lists, <span class="fixed">[2,5,10]</span> and <span class="fixed">[8,10,11]</span> and we want to get the products of all the possible combinations between numbers in those lists, here's what we'd do.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; [ x*y | x &lt;- [2,5,10], y &lt;- [8,10,11]]
[16,20,22,40,50,55,80,100,110] </pre>
<p>As expected, the length of the new list is 9. What if we wanted all possible products that are more than 50?</p>
<pre name="code" class="haskell: ghci">
ghci&gt; [ x*y | x &lt;- [2,5,10], y &lt;- [8,10,11], x*y &gt; 50]
[55,80,100,110] </pre>
<p>How about a list comprehension that combines a list of adjectives and a list of nouns &hellip; for epic hilarity.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; let nouns = ["hobo","frog","pope"]
ghci&gt; let adjectives = ["lazy","grouchy","scheming"]
ghci&gt; [adjective ++ " " ++ noun | adjective &lt;- adjectives, noun &lt;- nouns]
["lazy hobo","lazy frog","lazy pope","grouchy hobo","grouchy frog",
"grouchy pope","scheming hobo","scheming frog","scheming pope"] </pre>
<p>I know! Let's write our own version of <span class="fixed">length</span>! We'll call it <span class="fixed">length'</span>.</p>
<pre name="code" class="haskell: hs">
length' xs = sum [1 | _ &lt;- xs] </pre>
<p><span class="fixed">_</span> means that we don't care what we'll draw from the list anyway so instead of writing a variable name that we'll never use, we just write <span class="fixed">_</span>. This function replaces every element of a list with <span class="fixed">1</span> and then sums that up. This means that the resulting sum will be the length of our list.</p>
<p>Just a friendly reminder: because strings are lists, we can use list comprehensions to process and produce strings. Here's a function that takes a string and removes everything except uppercase letters from it.</p>
<pre name="code" class="haskell: hs">
removeNonUppercase st = [ c | c &lt;- st, c `elem` ['A'..'Z']] </pre>
<p>
Testing it out:
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; removeNonUppercase "Hahaha! Ahahaha!"
"HA"
ghci&gt; removeNonUppercase "IdontLIKEFROGS"
"ILIKEFROGS" </pre>
<p>The predicate here does all the work. It says that the character will be included in the new list only if it's an element of the list <span class="fixed">['A'..'Z']</span>. Nested list comprehensions are also possible if you're operating on lists that contain lists. A list contains several lists of numbers. Let's remove all odd numbers without flattening the list.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; let xxs = [[1,3,5,2,3,1,2,4,5],[1,2,3,4,5,6,7,8,9],[1,2,4,2,1,6,3,1,3,2,3,6]]
ghci&gt; [ [ x | x &lt;- xs, even x ] | xs &lt;- xxs]
[[2,2,4],[2,4,6,8],[2,4,2,6,2,6]]
</pre>
<p>You can write list comprehensions across several lines. So if you're not in GHCI, it's better to split longer list comprehensions across multiple lines, especially if they're nested.</p>
<a name="tuples"></a><h2>Tuples</h2>
<img src="http://s3.amazonaws.com/lyah/tuple.png" alt="tuples" class="right" width="160" height="162">
<p>In some ways, tuples are like lists &mdash; they are a way to store several values into a single value. However, there are a few fundamental differences. A list of numbers is a list of numbers. That's its type and it doesn't matter if it has only one number in it or an infinite amount of numbers. Tuples, however, are used when you know exactly how many values you want to combine and its type depends on how many components it has and the types of the components. They are denoted with parentheses and their components are separated by commas.</p>
<p>Another key difference is that they don't have to be homogenous. Unlike a list, a tuple can contain a combination of several types.</p>
<p>Think about how we'd represent a two-dimensional vector in Haskell. One way would be to use a list. That would kind of work. So what if we wanted to put a couple of vectors in a list to represent points of a shape on a two-dimensional plane? We could do something like <span class="fixed">[[1,2],[8,11],[4,5]]</span>. The problem with that method is that we could also do stuff like <span class="fixed">[[1,2],[8,11,5],[4,5]]</span>, which Haskell has no problem with since it's still a list of lists with numbers but it kind of doesn't make sense. But a tuple of size two (also called a pair) is its own type, which means that a list can't have a couple of pairs in it and then a triple (a tuple of size three), so let's use that instead. Instead of surrounding the vectors with square brackets, we use parentheses: <span class="fixed">[(1,2),(8,11),(4,5)]</span>. What if we tried to make a shape like <span class="fixed">[(1,2),(8,11,5),(4,5)]</span>? Well, we'd get this error:</p>
<pre name="code" class="haskell: ghci">
Couldn't match expected type `(t, t1)'
against inferred type `(t2, t3, t4)'
In the expression: (8, 11, 5)
In the expression: [(1, 2), (8, 11, 5), (4, 5)]
In the definition of `it': it = [(1, 2), (8, 11, 5), (4, 5)]
</pre>
<p>It's telling us that we tried to use a pair and a triple in the same list, which is not supposed to happen. You also couldn't make a list like <span class="fixed">[(1,2),("One",2)]</span> because the first element of the list is a pair of numbers and the second element is a pair consisting of a string and a number. Tuples can also be used to represent a wide variety of data. For instance, if we wanted to represent someone's name and age in Haskell, we could use a triple: <span class="fixed">("Christopher", "Walken", 55)</span>. As seen in this example, tuples can also contain lists.</p>
<p>Use tuples when you know in advance how many components some piece of data should have. Tuples are much more rigid because each different size of tuple is its own type, so you can't write a general function to append an element to a tuple &mdash; you'd have to write a function for appending to a pair, one function for appending to a triple, one function for appending to a 4-tuple, etc.</p>
<p>While there are singleton lists, there's no such thing as a singleton tuple. It doesn't really make much sense when you think about it. A singleton tuple would just be the value it contains and as such would have no benefit to us.</p>
<p>Like lists, tuples can be compared with each other if their components can be compared. Only you can't compare two tuples of different sizes, whereas you can compare two lists of different sizes. Two useful functions that operate on pairs:</p>
<p><span class="label function">fst</span> takes a pair and returns its first component.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; fst (8,11)
8
ghci&gt; fst ("Wow", False)
"Wow"</pre>
<p><span class="label function">snd</span> takes a pair and returns its second component. Surprise!</p>
<pre name="code" class="haskell: ghci">
ghci&gt; snd (8,11)
11
ghci&gt; snd ("Wow", False)
False</pre>
<div class="hintbox"><em>Note:</em> these functions operate only on pairs. They won't work on triples, 4-tuples, 5-tuples, etc. We'll go over extracting data from tuples in different ways a bit later.</div>
<p>A cool function that produces a list of pairs: <span class="label function">zip</span>. It takes two lists and then zips them together into one list by joining the matching elements into pairs. It's a really simple function but it has loads of uses. It's especially useful for when you want to combine two lists in a way or traverse two lists simultaneously. Here's a demonstration.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; zip [1,2,3,4,5] [5,5,5,5,5]
[(1,5),(2,5),(3,5),(4,5),(5,5)]
ghci&gt; zip [1 .. 5] ["one", "two", "three", "four", "five"]
[(1,"one"),(2,"two"),(3,"three"),(4,"four"),(5,"five")]
</pre>
<p>It pairs up the elements and produces a new list. The first element goes with the first, the second with the second, etc. Notice that because pairs can have different types in them, <span class="fixed">zip</span> can take two lists that contain different types and zip them up. What happens if the lengths of the lists don't match?</p>
<pre name="code" class="haskell: ghci">
ghci&gt; zip [5,3,2,6,2,7,2,5,4,6,6] ["im","a","turtle"]
[(5,"im"),(3,"a"),(2,"turtle")]
</pre>
<p>The longer list simply gets cut off to match the length of the shorter one. Because Haskell is lazy, we can zip finite lists with infinite lists:</p>
<pre name="code" class="haskell: ghci">
ghci&gt; zip [1..] ["apple", "orange", "cherry", "mango"]
[(1,"apple"),(2,"orange"),(3,"cherry"),(4,"mango")]
</pre>
<img src="http://s3.amazonaws.com/lyah/pythag.png" alt="look at meee" class="center" width="350" height="315">
<p>Here's a problem that combines tuples and list comprehensions: which right triangle that has integers for all sides and all sides equal to or smaller than 10 has a perimeter of 24? First, let's try generating all triangles with sides equal to or smaller than 10:</p>
<pre name="code" class="haskell: ghci">ghci&gt; let triangles = [ (a,b,c) | c &lt;- [1..10], b &lt;- [1..10], a &lt;- [1..10] ] </pre>
<p>We're just drawing from three lists and our output function is combining them into a triple. If you evaluate that by typing out <span class="fixed">triangles</span> in GHCI, you'll get a list of all possible triangles with sides under or equal to 10. Next, we'll add a condition that they all have to be right triangles. We'll also modify this function by taking into consideration that side b isn't larger than the hypothenuse and that side a isn't larger than side b.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; let rightTriangles = [ (a,b,c) | c &lt;- [1..10], b &lt;- [1..c], a &lt;- [1..b], a^2 + b^2 == c^2] </pre>
<p>We're almost done. Now, we just modify the function by saying that we want the ones where the perimeter is 24.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; let rightTriangles' = [ (a,b,c) | c &lt;- [1..10], b &lt;- [1..c], a &lt;- [1..b], a^2 + b^2 == c^2, a+b+c == 24]
ghci&gt; rightTriangles'
[(6,8,10)]
</pre>
<p>And there's our answer! This is a common pattern in functional programming. You take a starting set of solutions and then you apply transformations to those solutions and filter them until you get the right ones.</p>
                <div class="footdiv">
                <ul>
                    <li style="text-align:left">
                                                        <a href="introduction" class="prevlink">Introduction</a>
                                            </li>
                    <li style="text-align:center">
                        <a href="chapters">Table of contents</a>
                    </li>
                    <li style="text-align:right">
                                                        <a href="types-and-typeclasses" class="nxtlink">Types and Typeclasses</a>
                                            </li>
                </ul>
            </div>
        </div>
    <script type="text/javascript" src="sh/Scripts/shCore.js"></script>
    <script type="text/javascript" src="shBrushHaskell.js"></script>
    <script type="text/javascript" src="shBrushPlain.js"></script>
    <script type="text/javascript">
    dp.SyntaxHighlighter.ClipboardSwf = '/sh/Scripts/clipboard.swf';
    dp.SyntaxHighlighter.HighlightAll('code', false, false, false, 1, false);
    </script>
</div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-4461592-3");
pageTracker._trackPageview();
</script>
</body>
</html>
