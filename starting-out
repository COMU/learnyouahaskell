<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN"
   "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<title>Starting Out - Learn You a Haskell for Great Good!</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<base href="http://learnyouahaskell.com/">
<style type="text/css">
	@import url('reset.css');
	@import url('style.css');
</style>
<link rel="shortcut icon" href="favicon.png" type="image/png">
        <link rel="prev" href="introduction">
        <link rel="next" href="types-and-typeclasses">
<link type="text/css" rel="stylesheet" href="sh/Styles/SyntaxHighlighter.css">
<link href="rss.php" rel="alternate" type="application/rss+xml" title="Learn You a Haskell for Great Good! feed">
</head>
<body class="introcontent">
<div class="bgwrapper">
    <div id="content">
                <div class="footdiv" style="margin-bottom:25px;">
                <ul>
                    <li style="text-align:left">
                                                        <a href="introduction" class="prevlink">Tanıtım</a>
                                            </li>
                    <li style="text-align:center">
                        <a href="chapters">İçindekiler</a>
                    </li>
                    <li style="text-align:right">
                                                        <a href="types-and-typeclasses" class="nxtlink">Tipler ve Tip Sınıfları</a>
                                            </li>
                </ul>
            </div>
        <h1 style="margin-left:-3px">İlk Adım</h1>
<a name="ready-set-go"></a><h2>Hazır, başla!</h2>
<p>
<img src="http://s3.amazonaws.com/lyah/startingout.png" class="right" alt="egg" width="214" height="187">
Tamam, haydi başlayalım! Eğer tanıtımı okumadan geçen sabırsız kişilerdensen, tanıtımın son kısmını okumak isteyebilirsin çünkü bu eğitimi takip etmek için neye ihtiyacın olduğunu ve nasıl fonksiyon yükleyeceğimizi açıklıyor. Haskell hakkında temel bir fikir edinmeniz için yapacağımız ilk şey ghc'yi interaktif modda çalıştırmak ve bazı fonksiyonlar çağırmak olacak. Terminalinizi açın ve <span class="fixed">ghci</span> yazın. Böyle bir şeyle karşılacaksınız.
</p>
<pre name="code" class="haskell: ghci">
GHCi, version 6.8.2: http://www.haskell.org/ghc/  :? for help
Loading package base ... linking ... done.
Prelude&gt;</pre>
<p>
Tebrikler, GHCI'desiniz! Burada karşılaştığımız prompt <span class="fixed">Prelude&gt;</span> ama biz <span class="fixed">ghci&gt;</span> kullanacağız çünkü oturum içerisinde bir şeyler yapmak uzun zaman alabilir. Sizde de aynı prompt olsun istiyorsanız, sadece <span class="fixed">:set prompt "ghci&gt; "</span> yazın. Bu sadece nerede olduğumuzu bize hatırlatır.
</p>
<p>
İşte bazı basit aritmetikler.
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; 2 + 15
17
ghci&gt; 49 * 100
4900
ghci&gt; 1892 - 1472
420
ghci&gt; 5 / 2
2.5
ghci&gt;</pre>
<p>
Burası oldukça anlaşılır. Bir satırda birkaç işleç de kullanabiliriz. İşlem önceliği alışıldığı gibidir. Önceliği değiştirmek ve ya açıklık getirmek için parantezlerden yararlanabiliriz.
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; (50 * 100) - 4999
1
ghci&gt; 50 * 100 - 4999
1
ghci&gt; 50 * (100 - 4999)
-244950</pre>
<p>
Oldukça harika, değil mi? Tamam, biliyorum değil ama sabredin. Sayıları negatif hale getirirken biraz dikkat etmek gerekiyor. Eğer bir negatif sayı istiyorsak, her zaman en iyisi onu parantezlerle çevrelemek. Böyle yazarsan <span class="fixed">5 * -3</span> GHCI seni uyaracaktır ama böyle yazarsan <span class="fixed">5 * (-3)</span> sorunsuz çalışacaktır.
</p>
<p>
Boolean cebri de oldukça basit. Muhtemelen bilirsin, <span class="fixed">&amp;&amp;</span> boolen <i>ve</i>, <span class="fixed">||</span> boolen <i>ve ya</i> anlamına geliyor. <span class="fixed">not</span>, <span class="fixed">True</span> ve ya <span class="fixed">False</span>'u negatif hale çevirir.
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; True &amp;&amp; False
False
ghci&gt; True &amp;&amp; True
True
ghci&gt; False || True
True 
ghci&gt; not False
True
ghci&gt; not (True &amp;&amp; True)
False</pre>
<p>
Eşitliği test etmek şöyle yapılabilir.
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; 5 == 5
True
ghci&gt; 1 == 0
False
ghci&gt; 5 /= 5
False
ghci&gt; 5 /= 4
True
ghci&gt; "hello" == "hello"
True </pre>
<p>
Acaba <span class="fixed">5 + "llama"</span> ya da <span class="fixed">5 == True</span> yaparsak ne olur? Eğer ilk kodu denersek, büyük korkunç bir hata mesajı alırız!
</p>
<pre name="code" class="haskell: ghci">
No instance for (Num [Char])
arising from a use of `+' at &lt;interactive&gt;:1:0-9
Possible fix: add an instance declaration for (Num [Char])
In the expression: 5 + "llama"
In the definition of `it': it = 5 + "llama" </pre>
<p>
Eyvah! Burada GHCI bize <span class="fixed">"llama"</span>'nın bir sayı olmadığını ve 5'e nasıl ekleyeceğini bilmediğini söylüyor. Eğer <span class="fixed">"llama"</span> değil <span class="fixed">"four"</span> ya da <span class="fixed">"4"</span> olsaydı, Haskell hala onun sayı olduğunu anlayamazdı. <span class="fixed">+</span> sağ ve sol tarafının sayı olmasını bekler. Eğer <span class="fixed">True == 5</span> denersek, GHCI bize tiplerin uyuşmadığını söyler. Oysa <span class="fixed">+</span> sadece sayı kabul edilen şeyler üzerinde çalışırken, <span class="fixed">==</span> karşılaştırılabilen herhangi iki şey üzerinde çalışır. Ama önemli nokta her ikisinin de aynı tip materyalleri işleyebilmesi. Elma ile portakalı karşılaştıramazsın. İleride tiplere daha yakından bakacağız. Not: <span class="fixed">5 + 4.0</span> yazabilirsin çünkü <span class="fixed">5</span> sinsidir ve hem tam sayı hem de küsürlü sayı gibi davranabilir. <span class="fixed">4.0</span> tam sayı gibi davranamaz, bu yüzden <span class="fixed">5</span> de buna ayak uydurmak zorudadır.
</p>
<p>
Fark etmemiş olabilirsin ama başından beri hep fonksiyonları kullandık. Örneğin, <span class="fixed">*</span> iki sayı alan ve onları çarpan bir fonksiyon. Az önce gördüğün gibi, onu iki sayı arasında çağırmıştık. Biz böyle fonksiyonlara <i>infix</i> fonksiyon diyoruz. Sayılarla beraber kullanılmayan birçok fonksiyon <i>prefix</i> fonksiyondur. Haydi onlara bakalım. 
</p>
<p>
<img src="http://s3.amazonaws.com/lyah/ringring.png" alt="phoen" class="right" width="160" height="161">
Şimdiye kadar belitmemiştik ama kullandığımız fonksiyonlar çoğunlukla prefix yapıdaydı, biraz önce bundan bahsettik. Çoğu imperatif dilde fonksiyonlar, fonksiyon adı ile çağırılır ardından parantez içerisinde paramatreleri vardır, parametlerler de genellikle virgüllerle ayrılır. Haskell'de fonksiyonlar, fonksiyon adı sonra bir boşluk ardından parametlerleri yazılarak çağırılır. Parametreler de birbirlerinden birer boşlukla ayrılır. Başlangıç için, Haskell'deki en sıkıcı fonksiyonlardan birini çağırmayı deneyeceğiz.
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; succ 8
9 </pre>
<p>
<span class="fixed">succ</span> fonksiyonu ardılı olan herhangi bir şey alır ve onun ardılını döndürür. Gördüğün gibi, fonksiyon adını parametresinden bir boşlukla ayırdık. Bir fonksiyonu birkaç parametreyle çağırmak da kolay. <span class="fixed">min</span> ve <span class="fixed">max</span> fonksiyonları sıralanabilecek herhangi iki şey alır (sayı gibi!). <span class="fixed">min</span> küçük olanı döndürürken and <span class="fixed">max</span> büyük olanı döndürür. Kendin bak:
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; min 9 10
9
ghci&gt; min 3.4 3.2
3.2
ghci&gt; max 100 101
101 </pre>

<p>
Fonksiyon kullanımı (fonksiyon çağırma ardından birer boşlukla parametreleri yazmak) en yüksek önceliklidir. Bu aşağıdaki iki ifadenin eşit olduğu anlamına geliyor.
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; succ 9 + max 5 4 + 1
16
ghci&gt; (succ 9) + (max 5 4) + 1
16
</pre>
<p>
Eğer 9 ve 10'un sonucunun bir fazlasını istiyorsak, <span class="fixed">succ 9 * 10</span> yazmamalıyız çünkü bu 9'un bir fazlası ile 10'un çarpımıdır. Yani 100. 91 sonucunu almak için <span class="fixed">succ (9 * 10)</span> yazmalıyız.
</p>
<p>Eğer fonksiyon iki parametre alıyorsa, fonksiyonu backticklerin arasına alarak infix yapıda da çağırabiliriz. Örneğin, <span class="fixed">div</span> fonksiyonu iki tamsayı alır ve tam bölme yapar. <span class="fixed">div 92 10</span> işleminin sonucu 9'dur. Ama bu şekilde çağırmamız bölen ile bölüneni karıştırmamıza neden olabilir. İnfix fonksiyon olarak çağırdığımızda ise, <span class="fixed">92 `div` 10</span> aniden daha anlaşılır oldu. </p>
<p>İmperatif dillerle geçmişi olan çoğu insan parantezin fonksiyon bildirmesi gerektiği düşüncesinden sapamıyor. Örneğin, C'de <span class="fixed">foo()</span>, <span class="fixed">bar(1)</span> ya da <span class="fixed">baz(3, "haha")</span> gibi fonksiyonları parantezlerle çağırırsın. Söylediğimiz gibi, Haskell'de fonksiyon kullanımında boşluklar kullanılır. Bu fonksiyonlar Haskell'de <span class="fixed">foo</span>, <span class="fixed">bar 1</span> ve <span class="fixed">baz 3 "haha"</span> şeklinde olmalıdır. <span class="fixed">bar (bar 3)</span> gibi bir şey görürsen; <span class="fixed">bar</span>, <span class="fixed">bar</span> ve <span class="fixed">3</span> parametreleriyle çağırılmış anlamına gelmez. Bu <span class="fixed">bar</span> fonksiyonunu <span class="fixed">3</span> parametresi ile çağırıp, bundan elde edilen sonuc ile yine <span class="fixed">bar</span> fonksiyonunu çağırdığımız anlamına gelir. C'de, bu şekilde olmalı <span class="fixed">bar(bar(3))</span>.</p>
<a name="babys-first-functions"></a><h2>İlk fonksiyonlarımız</h2>
<p>
Önceki bölümde fonksiyon kullanımları ile ilgili temel fikir edindik. Haydi şimdi iyice anlayalım! En sevdiğin metin editörünü aç ve bir sayı alıp onu ikiyle çarpan bir fonksiyon yaz.
</p>
<pre name="code" class="haskell: hs">
doubleMe x = x + x</pre>
<p>
Fonksiyonlar, çağırımlarına benzer şekilde tanımlanır. Önce fonksiyon adı yazılır ardından parametreleri de aralarında boşluk olacak şekilde yerleştirilir. Ama fonksiyon tanımlarken, <span class="fixed">=</span> kullanılır ardından da fonksiyonun ne yaptığı tanımlanır. Bunu <span class="fixed">baby.hs</span> olarak kaydedin. Kaydettiğiniz dizine gidin ve <span class="fixed">ghci</span>'yi orada çalıştırın. GHCI içinde bir kez <span class="fixed">:l baby</span> yapın. Şimdi scriptimiz yüklendi, artık tanımladığımız fonksiyonlarla oynayabiliriz.
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; :l baby
[1 of 1] Compiling Main             ( baby.hs, interpreted )
Ok, modules loaded: Main.
ghci&gt; doubleMe 9
18
ghci&gt; doubleMe 8.3
16.6 </pre>
<p>
Çünkü <span class="fixed">+</span> tamsayılarla çalıştığı gibi gerçel sayılarla da çalışır (Herhangi birşey sayı olarak kabul edilebilir, gerçekten),fonksiyonumuz herhangi bir sayıyla da çalışır. Haydi bir fonksiyon yazalım. Bu fonksiyon iki sayı alsın, onları iki ile çarpıp birbiri ile toplasın.
</p>
<pre name="code" class="haskell: hs">
doubleUs x y = x*2 + y*2 </pre>
<p>
Basit. Şu şekilde de tanımlayabilirdik <span class="fixed">doubleUs x y = x + x + y + y</span>. Test edin, oldukça tahmin edilebilir sonuçlar veriyor (Unutma, bu fonksiyonu <span class="fixed">baby.hs</span> dosyasına ekleyip kaydettikten sonra GHCI içinde tekrar <span class="fixed">:l baby</span> yapmalısın).
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; doubleUs 4 9
26
ghci&gt; doubleUs 2.3 34.2
73.0
ghci&gt; doubleUs 28 88 + doubleMe 123
478
</pre>
<p>
Tahmin edeceğin gibi, kendi ürettiğin fonksiyonları yine kendi ürettiğin fonksiyonlarla çağırabilirsin. Yani, <span class="fixed">doubleUs</span> fonksiyonunu bu şekilde yeniden tanımlayabiliriz:
</p>
<pre name="code" class="haskell: hs">
doubleUs x y = doubleMe x + doubleMe y </pre>
<p>
Bu da Haskell boyunca karşılaşacağın genel şablona çok basit bir örnek. Basit fonksiyonlar yazmak ve onları birleştirerek daha karmaşık fonksiyonlar elde etmek oldukça doğru olur. Aynı zamanda basit fonksiyon içeriğini tekrarlama gereği kalmaz. Ya bazı matematikçiler 2'nin aslında 3 olduğunu bulur, senin de programını değiştirmen gerekirse? Sadece <span class="fixed">doubleMe</span>'yi <span class="fixed">x + x + x</span> olarak yeniden tanımlarsın. Artık <span class="fixed">doubleUs</span> yeni <span class="fixed">doubleMe</span> fonksiyonunu çağıracak ve 2'nin 3 olduğu bu garip dünyada otomatik olarak çalışacaktır.
</p>
<p>Haskell'de fonksiyonlar tanımlanırken belirli bir sıraları yoktur, yani <span class="fixed">doubleMe</span>'yi önce tanımlayıp sonra <span class="fixed">doubleUs</span>'ı tanımlaman bir şey değiştirmez. Bu diğer türlü yaparsan da geçerli.</p>
<p>Şimdi bir sayı alan ve onu 2 ile çarpan bir fonksiyon yazacağız ama bu fonksiyon eğer sayı 100'den küçük ya da eşitse onu 2 ile çarpıcak. Çünkü 100'den büyük sayılar yeterince büyükler.
</p>
<pre name="code" class="haskell: hs">
doubleSmallNumber x = if x &gt; 100
                        then x
                        else x*2 </pre>
<img src="http://s3.amazonaws.com/lyah/baby.png" alt="this is you" class="left" width="140" height="211">
<p>
Burada Haskell'deki if ile tanıştık. Muhtemelen if'e diğer dillerden alışkınsındır. Haskell'deki if ile imperatif dillerdeki if arasındaki fark ise else kısmının zorunlu olmasıdır. İmperatif dillerde eğer koşul sağlanmazsa sadece birkaç adımı atlarsın ama Haskell'de her ifade ve fonksiyon bir şey döndürmek zorundadır. Ayrıca if'i tek satırda da yazabiliriz. Haskell'deki if hakkında bir başka şey ise bir şey <i>ifade</i> etmesi yani değer döndürmesidir. <span class="fixed">5</span> 5 değerini döndüren bir ifadedir, <span class="fixed">4 + 8</span> bir ifadedir, <span class="fixed">x + y</span> de bir ifadedir çünkü <span class="fixed">x</span> ve <span class="fixed">y</span>'nin toplamının değerini döndürür. İf her zaman bir değer döndürür çünkü else kullanımı zorunludur. Bundan dolayı if her zaman bir ifadedir. Eğer fonksiyonumuz tarafından üretilmiş her değere bir eklemek istiyorsak, fonksiyonun gövdesini şu şekilde yazmalıyız.
</p>
<pre name="code" class="haskell: hs">
doubleSmallNumber' x = (if x &gt; 100 then x else x*2) + 1
</pre>
<p>
Eğer parantezleri ihmal etmiş olsaydık, sadece <span class="fixed">x</span> 100'den büyük olmadığı zaman 1 ekleyecekti. Fonksiyon adı sonundaki <span class="fixed">'</span> işaretine dikkat et. Kesme işareti Haskell'in sözdiziminde herhangi özel bir anlamı yoktur. Yani fonksiyon adlarında kullanılabilir. Genellikle, <span class="fixed">'</span> işaretini ya bir fonksiyonun son halini belirtmek için (burada tembel değil) ya da bir fonksiyon veya bir değişkenin ufak değişiklikler sonucunda son halini göstermek için kullanırız. Yani bu şekilde bir fonksiyon oluşturabiliriz.
</p>
<pre name="code" class="haskell: hs">
conanO'Brien = "It's a-me, Conan O'Brien!" </pre>
<p>
Burada kaydadeğer iki şey var. İlki fonksiyon başında yani Conan'ın adını yazarken büyük harfle başlamadık. Çünkü fonksiyon adları büyük harfle başlamaz. Neden olduğunu daha sonra göreceğiz. İkincisi bu fonksiyon hiç parametre almadı. Bir fonksiyon hiç parametre almadıysa, her zaman <i>tanımlama</i> olduğunu söyleriz (ya da <i>atama</i>). Çünkü bir kez tanımladıktan sonra isimlerin (ve fonksiyonların) anlamlarını değiştiremeyiz daha önce tanımladık zaten. <span class="fixed">conanO'Brien</span> ve <span class="fixed">"It's a-me, Conan O'Brien!"</span> dizgesi birbirinin yerine kullanılabilir.
</p>
<a name="an-intro-to-lists"></a><h2>Listelere giriş</h2>
<p>
<img src="http://s3.amazonaws.com/lyah/list.png" alt="BUY A DOG" class="left" width="150" height="103">
Haskell'deki listeler de gerçek hayattaki alışveriş listeleri gibi çok kullanışlıdır. En çok kullanılan veri yapısıdır. Birçok farklı yolla bir sürü problemi modelleyip çözmede kullanılabilir. Listeler ÇOK harikadır. Bu bölümde temel anlamda listelere, dizgelere (onlarda birer liste) ve liste kavramlarına göz atacağız.
</p>
<p>
Haskell'de listeler <em>türdeş</em> veri yapılarıdır. Aynı tipte olan birkaç öğe saklarlar. Yani bir birkaç tamsayı ve ya birkaç karakter saklayan listeler oluşturabiliriz ama aynı anda hem tamsayı hem de karakter içeren bir liste oluşturamayız. Ve sonunda bir liste!
</p>
<div class="hintbox"><em>Not</em>: GHCI'de <span class="fixed">let</span> anahtar kelimesini kullanarak bir ismi tanımlayabiliriz. GHCI'de <span class="fixed">let a = 1</span> yapmak ile bir komuta <span class="fixed">a = 1</span> yazıp, çalıştırmak aynı şeylerdir.</div>
<pre name="code" class="haskell: ghci">
ghci&gt; let lostNumbers = [4,8,15,16,23,42]
ghci&gt; lostNumbers
[4,8,15,16,23,42]
</pre>
<p>
Gördüğün gibi, listeler köşeli parantez ile belirtildi ve değerler virgüllerle birbirinden ayrıldı. Eğer <span class="fixed">[1,2,'a',3,'b','c',4]</span> şeklinde birşey denersek,  Haskell karakterlerin (Bu arada, kesme işareti arasına alınanlar karakter) sayı olamadığına yakınacaktır. Karakterlerden bahsetmişken, dizgeler de sadece karakterlerden oluşan listelerdir. <span class="fixed">"hello"</span> sadece <span class="fixed">['h','e','l','l','o']</span> dizisinin sadece sözdizimsel şekeridir. Dizgeler de birer liste olduğundan liste fonksiyonları onlar üzerinde de kullanabiliriz. Buda oldukça kullanışlı. 
</p>
<p>En çok yapılan iki listeyi birleştirme işlemi. Bunu <span class="fixed">++</span> işlecini ile yaparız. </p>
<pre name="code" class="haskell: ghci">
ghci&gt; [1,2,3,4] ++ [9,10,11,12]
[1,2,3,4,9,10,11,12]
ghci&gt; "hello" ++ " " ++ "world"
"hello world"
ghci&gt; ['w','o'] ++ ['o','t']
"woot"
</pre>
<p>
Uzun dizgelerde <span class="fixed">++</span> işlecini art arda kullanırken dikkatli ol. İki listeyi bir araya getirirken (hatta tek eleman tutan bir listeyi diğer listeye eklesen bile, öreneğin: <span class="fixed">[1,2,3] ++ [4]</span>), Haskell'in <span class="fixed">++</span> işlecinin sol tarafındaki listenin tümünü okuması gerekir. Bu çok büyük olmayan listelerle uğraşırken sorun değil. Ama elli milyon girdisi bulunan büyük bir listeye eklemek epey zaman alır. Oysa, bir listenin başına <span class="fixed">:</span> işlecini kullanarak şipşak birşey eklenebilir.
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; 'A':" SMALL CAT"
"A SMALL CAT"
ghci&gt; 5:[1,2,3,4,5]
[5,1,2,3,4,5]
</pre>
<p>
Uyarı. <span class="fixed">:</span> işleci bir sayı ve sayılardan oluşan liste ve ya bir karakter ve karakterlerden oluşan liste alır ,ama <span class="fixed">++</span> işleci iki liste alır. <span class="fixed">++</span> işleciyle listenin sonuna öğe eklesen bile, öğeyi köşeli parantezlerin arasına almalısın ki liste haline gelsin.</p>
<p>
<span class="fixed">[1,2,3]</span> de aslında sadece <span class="fixed">1:2:3:[]</span> ifadesinin sözdizimsel şekeridir. <span class="fixed">[]</span> bir boş listedir. Eğer başına <span class="fixed">3</span> eklersek, <span class="fixed">[3]</span> halini alır. Başına <span class="fixed">2</span> eklersek, <span class="fixed">[2,3]</span> olur, ve böyle devam eder.
</p>
<p class="hintbox"><em>Not:</em> <span class="fixed">[]</span>, <span class="fixed">[[]]</span> ve <span class="fixed">[[],[],[]]</span> frklı şeylerdir. İlki boş bir liste, ikincisi boş bir liste içeren bir liste, üçüncüsü ise üç tane boş liste içeren bir listeyi temsil eder.</p>
<p>Eğer listeden sırasına göre bir öğe çıkarmak istersen, <span class="fixed">!!</span> kullan. İndisler 0 dan başlar.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; "Steve Buscemi" !! 6
'B'
ghci&gt; [9.4,33.2,96.2,11.2,23.25] !! 1
33.2
</pre>
<p>Eğer dört elemanlı bir listenin altıncı elemanına ulaşmaya çalışırsan, hata alırsın. Bu yüzden dikkatli ol!</p>
<p>
Listeler aynı zamanda listeler içerebilir. Onlar da listeler içerebilir, onlar da, onlar da &hellip;
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; let b = [[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
ghci&gt; b
[[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
ghci&gt; b ++ [[1,1,1,1]]
[[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3],[1,1,1,1]]
ghci&gt; [6,6,6]:b
[[6,6,6],[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
ghci&gt; b !! 2
[1,2,2,3,4] </pre>
<p>Liste içerisinde listeler farklı uzunlukta olabilir ama farklı tipte öğe içeremezler. Bir liste içerisinde hem karakter hem sayı tutamadığımız gibi, hem karakter içeren listeler hem de sayı içeren listeler de tutamayız.</p>
<p>Eğer liste içerikleri karşılaştırılabiliyorsa listeler de karşılaştırılabilir. Listeler <span class="fixed">&lt;</span>, <span class="fixed">&lt;=</span>, <span class="fixed">&gt;</span> ve <span class="fixed">&gt;=</span> kullanarak sözlük sırasına göre karşılaştırılır. İlk önce baş eleman karşılaştırılır. Eğer onlar eşit ise ikinci elemanlar karşılaştırılır, vs.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; [3,2,1] &gt; [2,1,0]
True
ghci&gt; [3,2,1] &gt; [2,10,100]
True
ghci&gt; [3,4,2] &gt; [3,4]
True
ghci&gt; [3,4,2] &gt; [2,4]
True
ghci&gt; [3,4,2] == [3,4,2]
True
</pre>
<p>
Listeler ile başka neler yapabilirsin? İşte listeler üzerinde işlem yapan bazı temel fonksiyonlar.
</p>
<p><span class="label function">head</span> bir liste alır ve başını döndürür. Liste başı listenin ilk elemanıdır.
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; head [5,4,3,2,1]
5 </pre>
<p><span class="label function">tail</span> bir liste alır ve onun kuyruğunu döndürür. Başka bir deyişle, Liste başını keser, atar.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; tail [5,4,3,2,1]
[4,3,2,1] </pre>
<p><span class="label function">last</span> bir liste alır ve son elemanını döndürür.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; last [5,4,3,2,1]
1 </pre>
<p><span class="label function">init</span> bir liste alır ve son eleman harici tüm elemanları döndürür.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; init [5,4,3,2,1]
[5,4,3,2] </pre>
<p>Listenin bir canavar olduğunu varsayarsak, ne anlattığımız aşağıda daha açık.</p>
<img src="http://s3.amazonaws.com/lyah/listmonster.png" alt="list monster" class="center" width="580" height="290">
<p>Ama boş bir listenin başına ulaşmak istersek ne olur?</p>
<pre name="code" class="haskell: ghci">
ghci&gt; head []
*** Exception: Prelude.head: empty list</pre>
<p>Hadi be! Hepsini elimize, yüzümüze bulaştırdık! Eğer bir canavar yoksa, ortada herhangi bir baş olmaz. <span class="fixed">head</span>, <span class="fixed">tail</span>, <span class="fixed">last</span> ve <span class="fixed">init</span>, kullanırken listelerin boş olmamasına dikkat et. Bu hata ile derleme sırasında karşılaşılmaz bundan dolayı kazara haskell'in size boş listeden element getirmesini istemeye karşı önlem almak iyi bir alışkanlık olabilir.
<p><span class="label function">length</span> bir liste alır ve onun uzunluğunu döndürür.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; length [5,4,3,2,1]
5</pre>
<p><span class="label function">null</span> liste boş mu onu kontrol eder. Eğer boş ise <span class="fixed">True</span> döndürür, aksi takdirde <span class="fixed">False</span> döndürür. Bu fonksiyon <span class="fixed">xs == []</span> yerine kullanılabilir(<span class="fixed">xs</span> adında bir listen varsa).</p>
<pre name="code" class="haskell: ghci">
ghci&gt; null [1,2,3]
False
ghci&gt; null []
True</pre>
<p><span class="label function">reverse</span> listeyi ters çevirir.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; reverse [5,4,3,2,1]
[1,2,3,4,5]</pre>
<p><span class="label function">take</span> bir liste halinde sayı alır. Liste başındaki birçok eleman çeker. İzle ve gör.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; take 3 [5,4,3,2,1]
[5,4,3]
ghci&gt; take 1 [3,9,3]
[3]
ghci&gt; take 5 [1,2]
[1,2]
ghci&gt; take 0 [6,6,6]
[]</pre>
<p>Liste içerisinden ne kadar eleman alırsak alalım, elemanları bize liste halinde sunuyor. Eğer 0 eleman alırsak, boş liste elde ederiz.</p>
<p><span class="label function">drop</span> aynı şekilde çalışır, sadece liste başından aldığı parametre kadar elemanı listeden atar.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; drop 3 [8,4,2,1,5,6]
[1,5,6]
ghci&gt; drop 0 [1,2,3,4]
[1,2,3,4]
ghci&gt; drop 100 [1,2,3,4]
[] </pre>
<p><span class="label function">maximum</span> bir liste eleman alır herhangi bir şekilde düzene sahip bu elemanların en büyüğünü döndürür.</p><p> <span class="label function">minimum</span> da küçüğünü döndürür.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; minimum [8,4,2,1,5,6]
1
ghci&gt; maximum [1,9,2,3,4]
9 </pre>
<p><span class="label function">sum</span> bir liste sayı alır ve onların toplamını döndürür.</p><p><span class="label function">product</span> bir liste sayı alır ve çarpımlarını döndürür.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; sum [5,2,1,6,3,2,5,7]
31
ghci&gt; product [6,2,1,2]
24
ghci&gt; product [1,2,5,6,7,9,2,0]
0 </pre>
<p><span class="label function">elem</span> bir öğe ve o tip öğeler içeren bir liste alır ve o öğenin listenin elemanı olma durumunu araştırır. Genellikle infix fonksiyon olarak çağrılır çünkü bu şekilde okunması daha kolaydır.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; 4 `elem` [3,4,5,6]
True
ghci&gt; 10 `elem` [3,4,5,6]
False
</pre>
<p>Bu gördüklerimiz listeler üzerinde işlem yapan bazı temel fonksiyonlardı. Daha çok liste fonksiyonlarına daha <a href="modules#data-list">sonra</a> bakacağız.</p>
<a name="texas-ranges"></a><h2>Texas menzilleri</h2>
<p>
<img src="http://s3.amazonaws.com/lyah/cowboy.png" alt="draw" class="right" width="200" height="258">
Peki,1 ile 20 arasındaki sayıları içeren bir liste yapmak isteseydik ne yapardık? Tabiki 1'den 20'ye kadar olan sayıları sırayla yazabiliriz,fakat kullandığı programlama dilinden mükemmel bir şekilde yararlanmak isteyen bir centilmen bunu yapmak istemez. Bunun yerine texas menzillerini kullanacağız. Menziller numaralandırılabilen aritmetik serileri içeren listeleri yapmanın yollarından biridir. Sayılar numaralandırılabilir. Bir,iki,üç vs. Karakterler de numaralandırılabilir. Alfabe A'dan Z'ye kadar olan karakterlerin numaralandırılmış halidir. İsimler numaralandırılamaz. "Ali" den sonra ne gelir? Bilmem.
</p>
<p>1'den 20'ye kadar olan tüm sayıları içeren bir liste yapmak için, sadece <span class="fixed">[1..20]</span> yazabilirsiniz. Bu <span class="fixed">[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]</span> yazmakla aynıdır ,bu ikisinin arasındaki tek fark birinin uzun olmasıdır ve bana sorarsanız uzun olanı seçmek dümdüz salaklıktır.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; [1..20]
[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
ghci&gt; ['a'..'z']
"abcdefghijklmnopqrstuvwxyz"
ghci&gt; ['K'..'Z']
"KLMNOPQRSTUVWXYZ" </pre>
<p>
Menziller havalıdır çünkü bir atlamayı belirtebilirsiniz. 1 ile 20 arasındaki çift sayıları isteseydik nasıl isterdik? veya 1 ile 20 arasındaki 3'ün katlarını?
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; [2,4..20]
[2,4,6,8,10,12,14,16,18,20]
ghci&gt; [3,6..20]
[3,6,9,12,15,18] </pre>
<p>Bunu sadece ilk iki elementi virgülle ayırarak ve üst limitin ne olduğunu belirterek yapabilirsiniz. Haskell zekidir fakat bazı insanların olmasını istediği kadar değil. <span class="fixed">[1,2,4,8,16..100]</span> yazıp ikinin kuvvetlerini almayı bekleyemezsiniz. Bir;çünkü sadece bir atlama belirtebilirsiniz. İki;Eğer terimlerinden sadece birkaçı verildiyse aritmetik olmayan seriler belirsizdir.
</p>
<p>20'den 1'e kadar olan sayıların listesini yapmak isterseniz, sadece <span class="fixed">[20..1]</span> yazamazsınız, <span class="fixed">[20,19..1]</span> yazmak zorundasınız.</p>
<p>Menzillerde ondalıklı sayıları kullanırken dikkat edin! Çünkü tam değillerdir. Menzillerdeki kullanımları ilginç sonuçlara yol açabilir.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; [0.1, 0.3 .. 1]
[0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999]
</pre>
<p>Benim tavsiyem onları menzillerde kullanmayın.</p>
<p>
Menzilleri üst limit belirlemeyerek sınırsız listeler yaratmak için kullanabilirsiniz. Bunu sonra konuşacağız. Şimdi, 13'ün ilk 24 katını nasıl alabileceğinizi inceleyelim. Tabiki <span class="fixed">[13,26..24*13]</span> yazabilirsiniz. Fakat daha iyi bir yol var: <span class="fixed">take 24 [13,26..]</span>. Çünkü Haskell tembeldir, hemen sınırsız listeleri hesaplamaya çalışmayacaktır çünkü hiç bitiremez. Sizin bu listeden ne istediğinizi anlayana kadar bekleyecektir. Burda ilk 24 elementi istediğinizi gördüğü için memmuniyetle baş eğecektir.
</p>
<p>Sınırsız listeler oluşturmak için kullanılan birkaç fonksiyon:</p>
<p><span class="label function">cycle</span> bir liste alır ve onu sonsuz listeye devirler. Sonucu çıktı almaya çalışırsanız sonsuza kadar gidecektir yani bir yerde sizin bunu kesmeniz gerekir.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; take 10 (cycle [1,2,3])
[1,2,3,1,2,3,1,2,3,1]
ghci&gt; take 12 (cycle "LOL ")
"LOL LOL LOL " </pre>
<p><span class="label function">repeat</span> bir element alır ve sadece o elementten sonsuz bir liste yaratır. Bu tek element ile listeyi devirlemeye benzer.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; take 10 (repeat 5)
[5,5,5,5,5,5,5,5,5,5]
</pre>
<p>Aynı elementten listede birkaç tane istiyorsanız <span class="label function">replicate</span> fonksiyonunu da kullanabilirsiniz. <span class="fixed">replicate 3 10</span> yazarsanız <span class="fixed">[10,10,10]</span> döndürür.</p>
<a name="im-a-list-comprehension"></a><h2>Ben bir liste üreteciyim</h2>
<p>
<img src="http://s3.amazonaws.com/lyah/kermit.png" alt="frog" class="left" width="180" height="156">
Eğer daha önce bir matematik dersi aldıysanız büyük ihtimalle <i>dizi üreteçleri</i> ne bakmışsınızdır. Normalde genel dizilerden özel diziler oluşturmak için kullanılırlar. İlk 10 çift tamsayıyı üreten temel bir üreteç <img src="http://s3.amazonaws.com/lyah/setnotation.png" alt="set notation"> halinde yazılabilir. Borudan önceki kısım çıktı fonksiyonudur. <span class="fixed">x</span> değişken, <span class="fixed">N</span> girdi kümesi, <span class="fixed">x &lt;= 10</span> ise koşuldur. Bu listede koşulun önerdiği gibi 1'den 10'a kadar sayıların yazıldığı ve sonrasında ise listedeki her sayının 2 ile çarpıldığı anlamına gelir.
</p>
<p>Eğer bunu Haskell'da yazmak isteseydik <span class="fixed">take 10 [2,4..]</span> gibi birşey yazabilirdik. Peki atlama yerine 1'den 10'a kadar olan sayıları bir fonksiyona sokmak isteseydik? Bunun için liste üreteçlerini kullanmamız gerekir. Şimdilik ilk 10 çift tamsayıyı yazmak olarak işe başlayacağız. Kullanacağımız liste üreteci <span class="fixed">[x*2 | x &lt;- [1..10]]</span> olacak. <span class="fixed">x</span> ise burda <span class="fixed">[1..10]</span> listesindeki her eleman olacak. Uygulaması alttaki gibidir.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; [x*2 | x <- [1..10]]
[2,4,6,8,10,12,14,16,18,20]
</pre>
<p>Gördüğünüz üzere istediğimiz sonuçlara ulaştık. Şimdi fonksiyona bir koşul ekleyelim. Koşullar bağlayıcı bölümlerden sonra gelir ve virgül ile ayrılır. 12'ye eşit veya 12'den büyük olan çift sayıları istiyoruz diyelim.
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; [x*2 | x <- [1..10], x*2 >= 12]
[12,14,16,18,20]
</pre>
<p>Güzel,çalışıyor. Peki 50'den 100'e kadar olan sayıların içinde 7'ye bölündüğünde 3 kalanını veren sayıları bulalım desek? O da kolay .</p>
<pre name="code" class="haskell: ghci">
ghci&gt; [ x | x &lt;- [50..100], x `mod` 7 == 3]
[52,59,66,73,80,87,94] </pre>
<p>İşte bu! Listeleri koşullarla ayıklamaya aynı zamanda <em>süzme</em> denir. Bir dizi numara aldık ve onları koşullar ile süzdük. Şimdi başka bir örnek daha yapalım, 10'dan büyük her tek sayıyı <span class="fixed">"BANG!"</span>, 10'dan küçük olan her tek sayıyı <span class="fixed">"BOOM!"</span> ile değiştiren bir üreteç yapalım. Eğer sayı tek değilse listeden çıkartıyoruz. Kolaylık olsun diye bunu bir fonksiyonun içine koyacağız, sonrasında rahatça kullanalım diye.</p>
<pre name="code" class="haskell: ghci">
boomBangs xs = [ if x &lt; 10 then "BOOM!" else "BANG!" | x &lt;- xs, odd x] </pre>
<p>Üreteçin son kısmı koşuldur. <span class="fixed">odd</span> fonksiyonu tek sayılarda <span class="fixed">True</span> döndürürken çift sayılarda <span class="fixed">False</span> döndürür. Element listeye sadece koşullar sağlanıyorsa koyulur.
<pre name="code" class="haskell: hs">
ghci&gt; boomBangs [7..13]
["BOOM!","BOOM!","BANG!","BANG!"] </pre>
<p>Birden fazla koşul yaratabiliriz. Eğer 10'dan 20'ye kadar 13,15,19 olmayan tüm sayıları isteseydik bunu yapardık:</p> <pre name="code" class="haskell: ghci">
ghci&gt; [ x | x &lt;- [10..20], x /= 13, x /= 15, x /= 19]
[10,11,12,14,16,17,18,20]</pre>
<p>Liste üreteçlerinde birden fazla koşul almanın yanısıra, koşulları diğer listelerden de çekebiliriz. Bunu yaparken üreteçler verilen tüm listelerin kombinasyonlarını oluşturur ve onları bizim tedarik ettiğimiz çıktı fonksiyonuyla birleştirir. Yani 4 elemanlı 2 listenin bu yolla birleştirilmesinden oluşan bir üreteç 16 elemana sahip olacaktır. İsterseniz <span class="fixed">[2,5,10]</span> ve <span class="fixed">[8,10,11]</span> listeleriyle az önce söylediklerimizin uygulamasını yapalım.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; [ x*y | x &lt;- [2,5,10], y &lt;- [8,10,11]]
[16,20,22,40,50,55,80,100,110] </pre>
<p>Beklediğimiz gibi yeni listenin uzunluğu 9 eleman oldu, peki 50'den büyük olan kombinasyonları görmek isteseydik?</p>
<pre name="code" class="haskell: ghci">
ghci&gt; [ x*y | x &lt;- [2,5,10], y &lt;- [8,10,11], x*y &gt; 50]
[55,80,100,110] </pre>
<p>Bir dizi sıfat ve isimleri birleştiren bir üreteç yapsak &hellip; biraz şamata fena olmaz.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; let nouns = ["hobo","frog","pope"]
ghci&gt; let adjectives = ["lazy","grouchy","scheming"]
ghci&gt; [adjective ++ " " ++ noun | adjective &lt;- adjectives, noun &lt;- nouns]
["lazy hobo","lazy frog","lazy pope","grouchy hobo","grouchy frog",
"grouchy pope","scheming hobo","scheming frog","scheming pope"] </pre>
<p>Hadi <span class="fixed">length</span> 'in kendi versiyonumuzu yapalım! Ona da <span class="fixed">length'</span> diyelim.</p>
<pre name="code" class="haskell: hs">
length' xs = sum [1 | _ &lt;- xs] </pre>
<p><span class="fixed">_</span> işaretinin anlamı listeden çektiğimiz şeyin öneminin olmadığını gösterir,hiç kullanmayacağımız bir değişken almak yerine sadece <span class="fixed">_</span> yazmamız yeterlidir. Bu fonksiyon listenin her elemanını <span class="fixed">1</span> ile değiştirir ve sonrasında ise toplar. Bu toplamın listenin uzunluğu olacağı anlamına gelir.</p>
<p>Bir hatırlatma: Stringler aynı zamanda liste oldukları için liste üreteçlerini string üretmek için kullanabiliriz. Bir string alıp büyük harfler dışında stringdeki herşeyi silen bir üreteç yazalım.</p>
<pre name="code" class="haskell: hs">
removeNonUppercase st = [ c | c &lt;- st, c `elem` ['A'..'Z']] </pre>
<p>
Test edelim:
</p>
<pre name="code" class="haskell: ghci">
ghci&gt; removeNonUppercase "Hahaha! Ahahaha!"
"HA"
ghci&gt; removeNonUppercase "IdontLIKEFROGS"
"ILIKEFROGS" </pre>
<p>Burdaki tüm işi yapan yüklemin kendisidir. Burda yüklem bir karakterin sadece <span class="fixed">['A'..'Z']</span> listesinin içinden ise kabulünü sağlar. Eğer listenin içinde listerle iş yapıyorsanız iç içe olan liste üreteçlerini de kullanmak mümkündür. İçinde birkaç tane numara olan bir listeden tek olan sayıları listeyi düzleştirmeden çıkartalım.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; let xxs = [[1,3,5,2,3,1,2,4,5],[1,2,3,4,5,6,7,8,9],[1,2,4,2,1,6,3,1,3,2,3,6]]
ghci&gt; [ [ x | x &lt;- xs, even x ] | xs &lt;- xxs]
[[2,2,4],[2,4,6,8],[2,4,2,6,2,6]]
</pre>
<p>Liste üreteçlerini altalta yazabilirsiniz. Eğer GHCI'de değilseniz listeleri bu şekilde bölmek işinize yarayabilir, özellikle iç içeyseler.</p>
<a name="tuples"></a><h2>Demetler</h2>
<img src="http://s3.amazonaws.com/lyah/tuple.png" alt="tuples" class="right" width="160" height="162">
<p>Demetler bağzı yönleriyle listelere benzer &mdash; bu yapıların birden fazla değeri bir değerde saklaması benzer yanıdır. Ancak, aralarında birkaç temel farklılık vardır. Sayı listeleri sayı içeren listelerdir. Bu listenin tipidir ve içerisinde sadece bir ya da sonsuz miktarda sayı olması önemli değildir. Ancak, demetleri kullanırken tam olarak kaç tane değeri birleştirmek isteğinizi bilmelisiniz. Ve demetin tipi kaç tane bileşen içerdiği ve içerdiği bileşenlerin tipleri ile belirlenir. Demetler parantezler ile belirtilir ve bileşenleri virgüller ile birbirinde ayrılır.</p>
<p>Bir başka önemli fark ise demetler türdeş değildir. Listelerden farklı olarak demetler farklı tiplerde öğeler tutabilir.</p>
<p>Haskell'de iki boyutlu bir vektörü nasıl gösteririz bir düşün. Bir liste kullanmak çözüm olabilir. Peki bir listeye birden fazla vektör koyarak iki boyutlu düzlemde bir şeklin noktalarını belirtmek istersek? Buna benzer birşey yapabiliriz <span class="fixed">[[1,2],[8,11],[4,5]]</span>. Bu yöntemdeki sorun bunu şu şekilde de yapabilmemiz <span class="fixed">[[1,2],[8,11,5],[4,5]]</span>, Haskell burada sorun yaşamaz ama sayı listeleri içeren listeler olmasına rağmen anlamlı bir ifade olmaz. Ama iki boyutlu bir demet (bir başka deyişle çift) kendisi bir tiptir, bu da bir listenin birkaç çift ve bir üçlü (üç boyutlu demet) bulunduramayacağı anlamına gelir. Hadi diğeri yerine bunu kullanalım. Vektörleri çevreleyen köşeli parantezler yerine parantezler kullanalım: <span class="fixed">[(1,2),(8,11),(4,5)]</span>. Peki bu şekilde yapmayı denersek <span class="fixed">[(1,2),(8,11,5),(4,5)]</span>? Bu hatayı alırız:</p>
<pre name="code" class="haskell: ghci">
Couldn't match expected type `(t, t1)'
against inferred type `(t2, t3, t4)'
In the expression: (8, 11, 5)
In the expression: [(1, 2), (8, 11, 5), (4, 5)]
In the definition of `it': it = [(1, 2), (8, 11, 5), (4, 5)]
</pre>
<p>Bu hata bize iki boyulu bir demet ile üç boyutlu bir demeti aynı liste içerisinde kullandığımızı ve bunun mümkün olmadığını söylüyor. Ayrıca bu şekilde de liste oluşturamazsın <span class="fixed">[(1,2),("One",2)]</span> çünkü listenin ilk elemanı bir sayı çifti iken ikinci elemanı bir dizge ve bir sayı içeren çifttir. Ayrıca demetler geniş yelpazede veri çeşitliliği sunar. Örneğin, Haskell'de birinin adını ve yaşını belirtmek istiyorsak, üç boyutlu bir demet kullanırız: <span class="fixed">("Christopher", "Walken", 55)</span>. Örnekte görüldüğü gibi, demetler liste de içerebilir.</p>
<p>Demetleri önceden ne kadar bileşeni olması gerektiğini bildiğin veriler için kullan. Demetler çok daha katıdır çünkü her boyutta demet ayrı bir tip ifade eder, bu yüzden demetlere eleman ekleyen genel bir fonksiyon yazamazsın &mdash; İki boyutlu dizilere eleman eklemek için ayrı, üç boyutlular için ayrı, dört boyutlular için ayrı, vs.</p>
<p>Tek elemanlı listeler olmasına rağmen, tek bileşenli bir demet yoktur. Düşünürsek, zaten pek de mantıklı değil. Tek bileşenli demet bir tek değer tutar bunun da bize bir yararı yok.</p>
<p>Aynı listeler gibi, demetler de eğer içerikleri karşılaştırılabiliyorsa birbirleriyle karşılaştırılabilir. Sadece farklı boyutta listeleri karşılaştıramadığımız gibi, farklı boyutta demetleri de karşılaştıramayız. İki boyutlu demetlerde işlem yapan iki kullanışlı fonksiyon:</p>
<p><span class="label function">fst</span> iki boyutlu bir demet alır ve ilk bileşenini döndürür.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; fst (8,11)
8
ghci&gt; fst ("Wow", False)
"Wow"</pre>
<p><span class="label function">snd</span> iki boyutlu bir demet alır ve ikinci bileşenini dönürür. Sürpriz!</p>
<pre name="code" class="haskell: ghci">
ghci&gt; snd (8,11)
11
ghci&gt; snd ("Wow", False)
False</pre>
<div class="hintbox"><em>Not:</em> bu fonksiyonlar sadece iki boyutlu demetleri işleyebilir. Bunlar üzerinde işlem yapamaz: üçlüler, dörtlüler, beşliler, vs. Demetler üzerinden veri almanın farklı yollarını daha sonra göreceğiz.</div>
<p>İki boyutlu demetler ile işlem yapan havalı bir fonksiyon da: <span class="label function">zip</span>. İki liste alır ve listelerin karşılıklı elemanlarını iki boyutlu demetler halinde bir listede birleştirir. Çok basit bir fonksiyon ama birçok yerde kullanılır. Özellikle iki listeyi bir bakıma birleştirirken ya da iki liste elemanlarını eşzamanlı incelemek için kullanılır. İşte bir örnek.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; zip [1,2,3,4,5] [5,5,5,5,5]
[(1,5),(2,5),(3,5),(4,5),(5,5)]
ghci&gt; zip [1 .. 5] ["one", "two", "three", "four", "five"]
[(1,"one"),(2,"two"),(3,"three"),(4,"four"),(5,"five")]
</pre>
<p>Elemanları ikili demetler haline getirir ve yeni listeye ekler. İlk eleman diğer listenin ilk elemanıyla eşleşir, ikinci eleman diğer listenin ikinci elemanıyla, vs. İkili demetlerin kendi içinde bir tip olduğunu unutma, <span class="fixed">zip</span> farklı tipte elaman içeren iki listeyi de birleştirebilir. Peki listelerin uzunlukları uyuşmazsa ne olur?</p>
<pre name="code" class="haskell: ghci">
ghci&gt; zip [5,3,2,6,2,7,2,5,4,6,6] ["im","a","turtle"]
[(5,"im"),(3,"a"),(2,"turtle")]
</pre>
<p>Uzun olan listenin fazla olan kısmı atılır. Çünkü Haskell tembeldir, sonlu listeler ile sonsuz listeleri de zip ile birleştirebiliriz:</p>
<pre name="code" class="haskell: ghci">
ghci&gt; zip [1..] ["apple", "orange", "cherry", "mango"]
[(1,"apple"),(2,"orange"),(3,"cherry"),(4,"mango")]
</pre>
<img src="http://s3.amazonaws.com/lyah/pythag.png" alt="look at meee" class="center" width="350" height="315">
<p>İşte burada demetler ve liste üreteçlerini kullanırken bir sorun var. Tüm kenarları 10'dan küçük ve ya 10'a eşit tam sayılardan oluşan ve çevresi 24 olan bir dik üçgeni nasıl oluşturacağız? İlk önce kenarları 10'dan küçük ya da 10'a eşit tüm üçgenleri oluşturmaya çalışalım:</p>
<pre name="code" class="haskell: ghci">ghci&gt; let triangles = [ (a,b,c) | c &lt;- [1..10], b &lt;- [1..10], a &lt;- [1..10] ] </pre>
<p>Sadece üç tane liste oluşturduk ve oluşturduğumuz bu listeleri çıktı fonksiyonu ile üçlü demetler haline getirdik. Sonucu görmek için GHCI'de <span class="fixed">triangles</span> yaz, kenarları 10'dan küçük ya da 10'a eşit olası tüm üçgenlerin çıktısını alırsın. Sonra, hepsinin dik üçgen olması için bir koşul ekleyelim. Ayrıca b kenarının hipotenüsten büyük ve a kenarının b kenarından büyük olmaması gerektiğini de dikkate alarak, fonksiyona gerekli eklemeyi yapalım.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; let rightTriangles = [ (a,b,c) | c &lt;- [1..10], b &lt;- [1..c], a &lt;- [1..b], a^2 + b^2 == c^2] </pre>
<p>Neredeyse bitti. Şimdi, sadece çevresi 24 olanları istediğimiz için, fonksiyona bir ekleme daha yapalım.</p>
<pre name="code" class="haskell: ghci">
ghci&gt; let rightTriangles' = [ (a,b,c) | c &lt;- [1..10], b &lt;- [1..c], a &lt;- [1..b], a^2 + b^2 == c^2, a+b+c == 24]
ghci&gt; rightTriangles'
[(6,8,10)]
</pre>
<p>Ve aradığımız cevabı bulduk. Bu fonksiyonel programlamada genel bir şablondur. Bir takım çözümler üretmeye başlarsınız ardından bu çözümlere gerekli değişikliklerde bulunup en sonunda da onları doğru sonuca ulaşana kadar süzgeçten geçirirsiniz.</p>
                <div class="footdiv">
                <ul>
                    <li style="text-align:left">
                                                        <a href="introduction" class="prevlink">Tanıtım</a>
                                            </li>
                    <li style="text-align:center">
                        <a href="chapters">İçindekiler</a>
                    </li>
                    <li style="text-align:right">
                                                        <a href="types-and-typeclasses" class="nxtlink">Tipler ve Tip Sınıfları</a>
                                            </li>
                </ul>
            </div>
        </div>
    <script type="text/javascript" src="sh/Scripts/shCore.js"></script>
    <script type="text/javascript" src="shBrushHaskell.js"></script>
    <script type="text/javascript" src="shBrushPlain.js"></script>
    <script type="text/javascript">
    dp.SyntaxHighlighter.ClipboardSwf = '/sh/Scripts/clipboard.swf';
    dp.SyntaxHighlighter.HighlightAll('code', false, false, false, 1, false);
    </script>
</div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
var pageTracker = _gat._getTracker("UA-4461592-3");
pageTracker._trackPageview();
</script>
</body>
</html>
